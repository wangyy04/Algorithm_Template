# 字符串处理

## AC自动机

共有`T`次询问，对于每次询问，给定一个长字符串`s`和`n`个短字符串（即关键词）（分别编号为1~n），在`s`中寻找有哪些关键词出现过，存入`set<int> st`中。若将set改为vector，则可以统计各关键词分别出现的次数。

**注意：相同的关键词可以指定多个不同的编号，因为在struct Trie_Node中，id使用了vector存储。**

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;		//关键词的最大数量
const int MAXM = 26;			//字母个数
set<int> st;
struct Trie_Node
{
    vector<int> id;			    //关键词编号，不用时可省略
    int nxt[MAXM];
    int fail;
    int val;				    //关键词权值，不用时可省略
}trie[MAXN];
int idx;						//节点总数
void trie_clear()
{
    memset(trie, 0, sizeof(trie));
    idx = 0;
}
void trie_insert(char *s, int val)
{
    int len = strlen(s);
    int u = 0;
    for(int i = 0; i < len; i++)
    {
        int c = s[i] - 'a';
        if(!trie[u].nxt[c])
            trie[u].nxt[c] = ++idx;
        u = trie[u].nxt[c];
    }
    trie[u].id.push_back(val);
}
void ac_build()
{
    queue<int> q;
    for(int c = 0; c < MAXM; c++)
    {
        if(trie[0].nxt[c])
        {
            trie[trie[0].nxt[c]].fail = 0;
            q.push(trie[0].nxt[c]);
        }
    }
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        for(int c = 0; c < MAXM; c++)
        {
            int v = trie[u].nxt[c];
            if(v)
            {
                trie[v].fail = trie[trie[u].fail].nxt[c];
                //if(trie[trie[v].fail].id)		//若有一关键词是另一关键词后缀，忽略后缀的关键词；若不想忽略则注释这两行
                //    trie[v].id = trie[trie[v].fail].id;
                q.push(v);
            }
            else
            {
                trie[u].nxt[c] = trie[trie[u].fail].nxt[c];
            }
        }
    }
}
string a,C,b1,b2,B1[MAXN],B2[MAXN];
char s[MAXN];
bool vis[MAXN];								//关键词i是否出现过，与下一注释中的if语句配套使用
void ac_query()
{
    int u = 0;
    int len = strlen(s);
    for(int i = 0; i < len; i++)
    {
        int c = s[i] - 'a';
        u = trie[u].nxt[c];
        int v = u;
        while(v)
        {
            if(trie[v].id.size()>0)			//if(trie[v].id.size()>0 && !vis[v])
            {
                vis[v] = true;
                for (int i=0;i<trie[v].id.size();++i)
                    st.insert(trie[v].id[i]);
            }
            v = trie[v].fail;
        }
    }
}
int main()
{
    int T,n;
    cin>>T;
    while (T--)
    {
        cin>>n;
        memset(s,0,sizeof(s));
        cin>>s>>C;
        a=s;
        trie_clear();
        st.clear();
        for(int i = 1; i <= n; i++)
        {
            cin>>B1[i]>>B2[i];
            char *s_temp=const_cast<char*>(B1[i].c_str());		//string转char*
            trie_insert(s_temp,i);
        }
        ac_build();
        memset(vis, false, sizeof(vis));
        ac_query();
        for (set<int>::iterator ite=st.begin();ite!=st.end();ite++)
            cout<<*ite<<endl;
    }
    return 0;
}
```

> 函数说明：
>
> **void trie_clear()** 清空Trie树，当同一程序中需要多次进行不同的搜索时需清空以备后续建新的树。
>
> **void trie_insert(char *s, int val)** 新增关键词`s`，其编号为`val`。
>
> **void ac_build()** 建立Trie树。
>
> **void ac_query()** 搜索，结果存储于set<int> `st`中。



## KMP

共有`T`次询问，对于每次询问，给定一个短字符串`c`（即关键词）和`n`个长字符串（分别编号为1~n），寻找有哪些长字符串包含关键词，将其编号存入`vector<int> ans`中。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
const int MAXM = 26;
string a,C,b1,b2,B1[MAXN],B2[MAXN];
char s[MAXN];
vector <int> pre(string &pattern)
{
    int n=pattern.length();
    vector <int> next(n+1,0);
    for(int i=1;i<n;++i)
    {
        int j=i;
        while(j>0)
        {
            j=next[j];
            if(pattern[j]==pattern[i])
            {
                next[i+1]=j+1;
                break;
            }
        }
    }
    return next;
}
bool find_sub(string &pattern ,string &text,vector <int> &next)
{
    int n=pattern.length();
    int m=text.length();
    for(int i=0,j=0;i<m;++i)
    {
        if(j<n&&text[i]==pattern[j])
            j++;
        else
        {
            while(j>0)
            {
                j=next[j];
                if(text[i]==pattern[j])
                {
                    j++;
                    break;
                }
            }
        }
        if(j==n)
            return 1;
    }
    return 0;
}
int main()
{
    int T,n;
    cin>>T;
    while (T--)
    {
        cin>>n;
        memset(s,0,sizeof(s));
        cin>>s>>C;
        a=s;
        for(int i = 1; i <= n; i++)
            cin>>B1[i]>>B2[i];
        vector <int> c_next(pre(C));
        vector <int> ans;
        for(int i=1;i<=n;i++)
        {
            b1=B1[i];
            b2=B2[i];
            if(find_sub(C,b2,c_next))
            {
                ans.push_back(i);
            }
        }
        for(vector<int>::iterator it=ans.begin();it!=ans.end();it++)
        {
            if(it==ans.end()-1) cout<<*it;
            else cout<<*it<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```



### AC自动机+KMP例题：2024“钉耙编程”联赛第二场-1011 在A里面找有C的B

> ![image-20240724002310673](https://algorithm-template-1328964093.cos.ap-nanjing.myqcloud.com/image-20240724002310673.png)
>
> ![image-20240724002335844](https://algorithm-template-1328964093.cos.ap-nanjing.myqcloud.com/image-20240724002335844.png)
>
> 样例输入
>
> ```
> 2
> 5
> abcde a
> a a
> b a
> c b
> d a
> e c
> 5
> aaabbbccc xyz
> ab xxxyzzzzyy
> bccc aaaaxyza
> abbbb xxxxyyz
> aaaabbbcccc x
> a xyzzzzzzzzz
> ```
>
> 样例输出
>
> ```
> 1 2 4
> 1 2 5
> ```

先用AC自动机找在A中出现过的Bi，再用KMP（也可用字符串Hash）筛选包含C的Bi'。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
const int MAXM = 26;
set<int> st;
struct Trie_Node
{
    vector<int> id;
    int nxt[MAXM];
    int fail;
    int val;
}trie[MAXN];
int idx;
void trie_clear()
{
    memset(trie, 0, sizeof(trie));
    idx = 0;
}
void trie_insert(char *s, int val)
{
    int len = strlen(s);
    int u = 0;
    for(int i = 0; i < len; i++)
    {
        int c = s[i] - 'a';
        if(!trie[u].nxt[c])
            trie[u].nxt[c] = ++idx;
        u = trie[u].nxt[c];
    }
    trie[u].id.push_back(val);
}
void ac_build()
{
    queue<int> q;
    for(int c = 0; c < MAXM; c++)
    {
        if(trie[0].nxt[c])
        {
            trie[trie[0].nxt[c]].fail = 0;
            q.push(trie[0].nxt[c]);
        }
    }
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        for(int c = 0; c < MAXM; c++)
        {
            int v = trie[u].nxt[c];
            if(v)
            {
                trie[v].fail = trie[trie[u].fail].nxt[c];
                //if(trie[trie[v].fail].id)
                //    trie[v].id = trie[trie[v].fail].id;
                q.push(v);
            }
            else
            {
                trie[u].nxt[c] = trie[trie[u].fail].nxt[c];
            }
        }
    }
}
string a,C,b1,b2,B1[MAXN],B2[MAXN];
char s[MAXN];
//int pos[MAXN];
bool vis[MAXN];
void ac_query()
{
    int u = 0;
    int len = strlen(s);
    for(int i = 0; i < len; i++)
    {
        int c = s[i] - 'a';
        u = trie[u].nxt[c];
        int v = u;
        while(v)
        {
            if(trie[v].id.size()>0)
            {
                vis[v] = true;
                for (int i=0;i<trie[v].id.size();++i)
                    st.insert(trie[v].id[i]);
            }
            v = trie[v].fail;
        }
    }
}

vector <int>  pre(string &pattern)
{
    int n=pattern.length();
    vector <int> next(n+1,0);
    for(int i=1;i<n;++i)
    {
        int j=i;
        while(j>0)
        {
            j=next[j];
            if(pattern[j]==pattern[i])
            {
                next[i+1]=j+1;
                break;
            }
        }
    }
    return next;
}
bool find_sub(string &pattern ,string &text,vector <int> &next)
{
    int n=pattern.length();
    int m=text.length();
    for(int i=0,j=0;i<m;++i)
    {
        if(j<n&&text[i]==pattern[j])
            j++;
        else
        {
            while(j>0)
            {
                j=next[j];
                if(text[i]==pattern[j])
                {
                    j++;
                    break;
                }
            }
        }
        if(j==n)
            return 1;
    }
    return 0;
}

int main()
{
    int T,n;
    cin>>T;
    while (T--)
    {
        cin>>n;
        memset(s,0,sizeof(s));
        cin>>s>>C;
        a=s;
        trie_clear();
        st.clear();
        for(int i = 1; i <= n; i++)
        {
            cin>>B1[i]>>B2[i];
            if (B1[i]==a)
            {
                st.insert(i);
                continue;
            }
            char *s_temp=const_cast<char*>(B1[i].c_str());
            trie_insert(s_temp,i);
        }
        ac_build();
        memset(vis, false, sizeof(vis));
        ac_query();
        /*for (set<int>::iterator ite=st.begin();ite!=st.end();ite++)
            cout<<*ite<<endl;*/
        vector <int> c_next(pre(C));
        vector <int> ans;
        for(set<int>::iterator ite=st.begin();ite!=st.end();ite++)
        {
            int i=*ite;
            b1=B1[i];
            b2=B2[i];
            if(find_sub(C,b2,c_next))
            {
                ans.push_back(i);
            }
        }
        for(vector<int>::iterator it=ans.begin();it!=ans.end();it++)
        {
            if(it==ans.end()-1) cout<<*it;
            else cout<<*it<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```



## 扩展KMP/e-KMP

next[i]为x[i...(m-1)]与x[0...(m-1)]的最长公共前缀。

extend[i]为y[i...(n-1)]与x[0...(m-1)]的最长公共前缀。

当extend[i]=m时，意味着x作为y的子串出现在下标为i开始的位置。

```c++
void pre_EKMP(char x[],int m,int next[])
{
    next[0]=m;
    int j=0;
    while (j+1<m && x[j]==x[j+1]) j++;
    next[1]=j;
    int k=1;
    for (int i=2;i<m;i++)
    {
        int p=next[k]+k-1;
        int L=next[i-k];
        if (i+L<p+1)
            next[i]=L;
        else
        {
            j=max(0,p-i+1);
            while (i+j<m && x[i+j]==x[j]) j++;
            next[i]=j;
            k=i;
        }
    }
}
void EKMP(char x[],int m,char y[],int n,int next[],int extend[])
{
    pre_EKMP(x,m,next);
    int j=0;
    while (j<n && j<m && x[j]==y[j]) j++;
    extend[0]=j;
    int k=0;
    for (int i=1;i<n;i++)
    {
        int p=extend[k]+k-1;
        int L=next[i-k];
        if (i+L<p+1)
            extend[i]=L;
        else
        {
            j=max(0,p-i+1);
            while (i+j<n && j<m && y[i+j]==x[j]) j++;
            extend[i]=j;
            k=i;
        }
    }
}
```



## Boyer-Moore算法

寻找模式串在长字符串中第一次出现的位置下标（从0开始编号）。效率比KMP快3~5倍。

```c++
#include<iostream>
#include<string>
using namespace std;
//最长匹配长度
#define MAX_SIZE 1000
//得到后缀规则的移动距离
int GoodSuffix(int j, string& pat) {
	int terminal = pat.length() - 1;
	int index = -1;
	j--;
	while (j >= 0) {
		if (pat[j] == pat[terminal]) {
			index = j;
			break;
		}
		else j--;
	}
	return terminal - index;
}
//得到坏字符规则的移动距离
int BadChar(int j,char temp,string str)
{
	
	int index = -1;
	for (int i = j - 1; i >= 0; --i)
	{
		if (str[i] == temp)
		{
			index = i;
			break;
		}
	}
	return j - index;
}
int BM(string source, string target)
{
	int i = 0, j = 0, soulen = source.length(), tarlen = target.length();  //初始化
	int badvalue = 0, distance = 0;
	if (soulen < tarlen) {  //比较长度
		printf("字符串的长度小于搜索词的长度\n");
		return -1;
	}
	i = tarlen - 1; j = tarlen - 1; //从尾开始匹配
	while (i < soulen) {
		if (source[i] == target[j]) {  //字符匹配成功
			if (j == 0) {
				printf("匹配成功\n");
				return i;
			}
			i--; j--;
		}
		else {  //未匹配成功
			if (j == tarlen - 1) {  //如果尾字符未匹配成功，"坏字符规则"
				badvalue = BadChar(j, source[i],target);
				cout << "坏字符移动：" << badvalue << endl;
				i = i + tarlen - 1 - j + badvalue;
				j = tarlen - 1;
			}
			else {  //有后缀,比较"坏字符规则"和"后缀规则"
				badvalue = BadChar(j, source[i], target);
				if (badvalue == -1)
				badvalue = target.length();
				distance = badvalue > GoodSuffix(j,target) ? badvalue : GoodSuffix(j, target);
				cout << "好后缀为：" << GoodSuffix(j, target) << "  坏字符为：" << badvalue << "  比较之后移动" << distance << endl;
				i = i + tarlen - 1 - j + distance;  //更新i的位置
				j = tarlen - 1;   //更新j位置
				
			}
		}
	}
}
int main()
{
	//好后缀表:存储了当遇到好后缀时，目标串向右的移动距离。
	int* goodSuffix = new int[MAX_SIZE];
	string model = "THERE IS A SIMPLE EXAMPLE";
	string str = "EXAMPLE";
	cout << "模式串" << model << endl;
	cout << "目标串" << str << endl;
	cout << str << "的好后缀表为：" << endl;
	for (int i = 0; i < str.length(); ++i)
	{
		cout << str[i] << ":" << GoodSuffix(i,str) << endl;;
	}
	cout << "匹配成功的开始位置为：" << BM(model, str) << endl;
	delete[]goodSuffix;
	return 0;
}
```



## 字符串Hash

> 基本思想：将字符串看作P进制数，P通常取131或13331.

使用unsigned long long存储哈希值，这样溢出时相当于自动对2的64次方-1取模。

### 计算子串Hash

给定字符串A，第i位**（0<=i<A.length())**的哈希值h[i+1]=h[i]*P+A[i]。A的子串A[l...r] **(1<=l,r<A.length()+1)**的Hash值由Get(l,r)获得。

数组p[]用于存储P的幂，**注意要开long long**。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
const int N=1048576+100,P=131;
int n,m,T;
ULL h[N],p[N],ans;
string A,B,A_Copy;
ULL Get(int l, int r)
{
    return h[r]-h[l-1]*p[r-l+1];
}
int main()
{

	cin>>A;
    n=A.length();
    p[0]=1;
    for(int i=1;i<=n;i++)
    {
    	p[i]=p[i-1]*P;
		h[i]=h[i-1]*P+A[i-1];
	}
    return 0;
}
```



### 字符串双Hash

取两个不同的质数作为mod，用pair表示一个字符串的哈希值。

> mod值的选择：
>
> 不建议选择1e9+7,1e9+9。
>
> 上界和下界指的是离素数最近的2的n次方的值。
>
> | lwr  | upr  | % err     | prime      |
> | ---- | ---- | --------- | ---------- |
> | 2^5  | 2^6  | 10.416667 | 53         |
> | 2^6  | 2^7  | 1.041667  | 97         |
> | 2^7  | 2^8  | 0.520833  | 193        |
> | 2^8  | 2^9  | 1.302083  | 389        |
> | 2^9  | 2^10 | 0.130208  | 769        |
> | 2^10 | 2^11 | 0.455729  | 1543       |
> | 2^11 | 2^12 | 0.227865  | 3079       |
> | 2^12 | 2^13 | 0.113932  | 6151       |
> | 2^13 | 2^14 | 0.008138  | 12289      |
> | 2^14 | 2^15 | 0.069173  | 24593      |
> | 2^15 | 2^16 | 0.010173  | 49157      |
> | 2^16 | 2^17 | 0.013224  | 98317      |
> | 2^17 | 2^18 | 0.002543  | 196613     |
> | 2^18 | 2^19 | 0.006358  | 393241     |
> | 2^19 | 2^20 | 0.000127  | 786433     |
> | 2^20 | 2^21 | 0.000318  | 1572869    |
> | 2^21 | 2^22 | 0.000350  | 3145739    |
> | 2^22 | 2^23 | 0.000207  | 6291469    |
> | 2^23 | 2^24 | 0.000040  | 12582917   |
> | 2^24 | 2^25 | 0.000075  | 25165843   |
> | 2^25 | 2^26 | 0.000010  | 50331653   |
> | 2^26 | 2^27 | 0.000023  | 100663319  |
> | 2^27 | 2^28 | 0.000009  | 201326611  |
> | 2^28 | 2^29 | 0.000001  | 402653189  |
> | 2^29 | 2^30 | 0.000011  | 805306457  |
> | 2^30 | 2^31 | 0.000000  | 1610612741 |

```c++
string A;
cin>>A;
n=A.length();
for(int i=1;i<=n;i++)
{
    p[i]=p[i-1]*P;
    h1[i]=(h1[i-1]*P+A[i-1])%mod1;
    h2[i]=(h2[i-1]*P+A[i-1])%mod2;
}
```



## Rabin-Karp算法

计算子串哈希进行比较，比较哈希值采用“滚动哈希法”。其用时与KMP相近。

若计算哈希所用的质数为P，每次截取的子串长度为n，则`后移一位的子串hash=当前子串的hash*P-当前子串首字符*(P的n次方)+下一字符`

> 例如：
>
> 有字符串`"abcde"`，每次截取长度为3的子串。则`子串"abc"的hash=a*(P^2)+b*(P^1)+c*(P^0)`。
>
> 后移一位得子串`"bcd"`，`其hash=(a*(P^2)+b*(P^1)+c*(P^0))-a*(P^3)+d`.

```c++
#include <iostream>
#include <string.h>
using namespace std;
#define BASE 256
#define MODULUS 101
void RabinKarp(char t[], char p[])
{
    int t_len = strlen(t);
    int p_len = strlen(p);
    // 哈希滚动之用
    int h = 1;
    for (int i = 0; i < p_len - 1; i++)
        h = (h * BASE) % MODULUS;
    int t_hash = 0;
    int p_hash = 0;
    for (int i = 0; i < p_len; i++)
    {
        t_hash = (BASE * t_hash + t[i]) % MODULUS;
        p_hash = (BASE * p_hash + p[i]) % MODULUS;
    }
    int i = 0;
    while (i <= t_len - p_len)
    {
         // 考虑到哈希碰撞的可能性，还需要用 memcmp 再比对一下
        if (t_hash == p_hash && memcmp(p, t + i, p_len) == 0)
            cout << p << " is found at index " << i << endl;
        // 哈希滚动
        t_hash = (BASE * (t_hash - t[i] * h) + t[i + p_len]) % MODULUS;
        // 防止出现负数
        if (t_hash < 0)
            t_hash = t_hash + MODULUS;
        i++;
    }
}
int main()
{
    char t[100] = "It is a test, but not just a test";
    char p[10] = "test";
    RabinKarp(t, p);
    return 0;
}
```



## Manacher算法

给定一个字符串，求以每个位置（字符所在位置或两字符中间）为中心时对应的最长回文半径。回文中心本身不计入回文半径。

r[i]表示以第i个位置为中心的最长回文半径，**其长度包括了`"#"`字符**。

**注意：用于分隔原字符串各字符的字符应使用不会出现在原字符串中的字符，例如下面代码中使用的`"#"`字符。**

```c++
#include <bits/stdc++.h>
using namespace std;
string Get_new(string &str)
{
    string temp = "#";
    for (int i = 0; str[i]; i++)
    {
        (temp += str[i]) += "#";
    }
    return temp;
}
int main()
{
    string str;
    cin >> str;
    str = Get_new(str);
    int *r = (int *)calloc(sizeof(int), str.size()), c = 0, ans = 0;
    for (int i = 1; str[i]; i++)
    {
        if (c + r[c] > i)  r[i] = min(r[2 * c - i], c + r[c] - i);
        while (i - r[i] >= 0 && str[i - r[i]] == str[i + r[i]])  r[i]++;
        r[i]--;
        if (i + r[i] > c + r[c])  c = i;   //注意更新C的位置
        //ans = max(ans, r[i]);
        cout<<r[i]<<" ";
    }
    //cout << ans << endl;
    free(r);
    return 0;
}
```

> 函数说明：
>
> **string Get_new(string &str)** 在每个字符前后添加`#`,例如将`"abc"`变为`"#a#b#c#"`。



## 最长公共子序列(LCS)

输入两个分别包含n和m个元素的序列，输出其最大公共子序列及其长度。f[i]为最大公共子序列的第i位（1<=i<=len）。（若有多个仅输出其一）

```c++
#include<bits/stdc++.h>
using namespace std;
int len=0;
int a[100001],p[100001],f[100001];
int bound(int x)
{
    int L=1,R=len;
    while(L<R)
    {
        int mid=(L+R)>>1;
        if(p[f[mid]]>p[x])
            R=mid;
        else
            L=mid+1;
    }
    return L;
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        p[x]=i;
    }
    for(int i=1;i<=n;i++)
    {
        if(p[a[i]]>p[f[len]])
            f[++len]=a[i];
        else
            f[bound(a[i])]=a[i];
    }
    for (int i=1;i<=len;i++)
        cout<<f[i]<<" ";
    cout<<endl;
    cout<<len<<endl;
    return 0;
}
```



## 最长递增子序列(LIS)

给定一个数组，求其最长递增子序列。（若有多个仅输出其一）

```c++
class Solution {
   public:
    vector<int> findOneLIS(vector<int>& nums) {
        using Node = pair<int, int>;  // 槽位, {父节点在桶中的位置、元素值}
        using Bucket = vector<Node>;  // 桶
        vector<Bucket> buckets;  // 各个列的桶
        vector<int> p;           // 辅助数组, 冗余各个桶的尾部元素
        // 放入头节点到第一个桶
        buckets.push_back({{-1, nums[0]}});
        p.push_back(nums[0]);
        // 辅助函数, 给第 k 个桶放入一个新元素
        auto push = [&](int k, int num) {
            // 上个桶的当前尾部节点当做父节点
            int j = (k == 0) ? -1 : (buckets[k - 1].size() - 1);
            buckets[k].push_back({j, num});
            // 更新辅助数组
            p[k] = num;
        };
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > p[p.size() - 1]) {
                // 新建一个空桶, 扩展辅助数组
                buckets.push_back({});
                p.push_back(0);
                // 加入此元素到新桶 (最后一个桶)
                push(buckets.size() - 1, nums[i]);
            } else {
                // 查找合适的桶放入新元素
                int k = lower_bound(p.begin(), p.end(), nums[i]) - p.begin();
                push(k, nums[i]);
            }
        }
        // 要返回最长的上升子序列，需要从最后一个桶反向找回去
        vector<int> ans(buckets.size());
        // i 是第 i 个桶，j 父节点在前面一个桶的位置
        for (int i = buckets.size() - 1, j = -1; i >= 0; i--) {
            auto& b = buckets[i];
            auto& [j1, num] = b[j < 0 ? (b.size() - 1) : j];
            j = j1;
            ans[i] = num;
        }
        return ans;
    }
};
```



## 后缀数组

> 后缀数组定义：给定一个字符串，将其所有的后缀字符串按字典序从小到大排序，将其起点下标依次记录在数组中，即为后缀数组。

后缀数组不仅可用于字符串，还可用于数组。

### DC3算法

r[]数组中存放待排序字符串（下标从0开始）（需使用int表示字符）**（为便于操作，建议除了r[n-1]外的r[i]大于0）**，n表示字符串长度，m应大于r[]中的最大值，sa[]数组用于储存dc3函数计算后得到的后缀数组。

**注意：所有的数组都要开三倍**

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2010;
#define F(x) ((x)/3+((x)%3==1?0:tb))
#define G(x) ((x)<tb?(x)*3+1:((x)-tb)*3+2)
int wa[MAXN*3],wb[MAXN*3],wv[MAXN*3],wss[MAXN*3];
string str;
int c0(int *r,int a,int b)
{
    return r[a] == r[b] && r[a+1] == r[b+1] && r[a+2] == r[b+2];
}
int c12(int k,int *r,int a,int b)
{
    if(k == 2)
        return r[a] < r[b] || ( r[a] == r[b] && c12(1,r,a+1,b+1) );
    else
        return r[a] < r[b] || ( r[a] == r[b] && wv[a+1] < wv[b+1]);
}
void sort(int *r,int *a,int *b,int n,int m)
{
    int i;
    for(i = 0;i < n;i++) wv[i] = r[a[i]];
    for(i = 0;i < m;i++) wss[i] = 0;
    for(i = 0;i < n;i++) wss[wv[i]]++;
    for(i = 1;i < m;i++) wss[i] += wss[i-1];
    for(i = n-1;i >= 0;i--)
    b[--wss[wv[i]]] = a[i];
}
void dc3(int *r,int *sa,int n,int m)
{
    int i, j, *rn = r + n;
    int *san = sa + n, ta = 0, tb = (n+1)/3, tbc = 0, p;
    r[n] = r[n+1] = 0;
    for(i = 0;i < n;i++)
        if(i %3 != 0) wa[tbc++] = i;
    sort(r + 2, wa, wb, tbc, m);
    sort(r + 1, wb, wa, tbc, m);
    sort(r, wa, wb, tbc, m);
    for(p = 1, rn[F(wb[0])] = 0, i = 1;i < tbc;i++)
        rn[F(wb[i])] = c0(r, wb[i-1], wb[i]) ? p - 1 : p++;
    if(p < tbc)
        dc3(rn,san,tbc,p);
    else
        for(i = 0;i < tbc;i++) san[rn[i]] = i;
    for(i = 0;i < tbc;i++)
        if(san[i] < tb) wb[ta++] = san[i] * 3;
    if(n % 3 == 1) wb[ta++] = n - 1;
    sort(r, wb, wa, ta, m);
    for(i = 0;i < tbc;i++)
        wv[wb[i] = G(san[i])] = i;
    for(i = 0, j = 0, p = 0;i < ta && j < tbc;p++)
        sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++];
    for(;i < ta;p++)
        sa[p] = wa[i++];
    for(;j < tbc;p++)
        sa[p] = wb[j++];
}
int main()
{
    int m,n;
    int r[MAXN*3],sa[MAXN*3];
    cin>>str;
    m=0;
    n=str.length();
    for (int i=0;i<n;i++)
    {
        r[i]=str[i]-'a'+1;
        m=max(r[i],m);
    }
    m++;
    dc3(r,sa,n,m);
    for (int i=0;i<n;i++)
        cout<<sa[i]<<" ";
    return 0;
}
```



### DA算法

r[]数组中存放待排序字符串（下标从0开始）（需使用int表示字符）**（为便于操作，建议除了r[n-1]外的r[i]大于0）**，n表示字符串长度，m应大于r[]中的最大值，sa[]数组用于储存da函数计算后得到的后缀数组。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN=2010;
int wa[MAXN],wb[MAXN],wv[MAXN],wss[MAXN];
string str;
int cmp(int *r,int a,int b,int l)
{
    return r[a]==r[b]&&r[a+l]==r[b+l];
}
void da(int *r,int *sa,int n,int m)
{
    int i,j,p,*x=wa,*y=wb,*t;
    for(i=0;i<m;i++) wss[i]=0;
    for(i=0;i<n;i++) wss[x[i]=r[i]]++;
    for(i=1;i<m;i++) wss[i]+=wss[i-1];
    for(i=n-1;i>=0;i--) sa[--wss[x[i]]]=i;
    for(j=1,p=1;p<n;j*=2,m=p)
    {
        for(p=0,i=n-j;i<n;i++) y[p++]=i;
        for(i=0;i<n;i++) if(sa[i]>=j) y[p++]=sa[i]-j;
        for(i=0;i<n;i++) wv[i]=x[y[i]];
        for(i=0;i<m;i++) wss[i]=0;
        for(i=0;i<n;i++) wss[wv[i]]++;
        for(i=1;i<m;i++) wss[i]+=wss[i-1];
        for(i=n-1;i>=0;i--) sa[--wss[wv[i]]]=y[i];
        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i<n;i++)
            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
    }
    return;
}
int main()
{
    int m,n;
    int r[MAXN],sa[MAXN];
    cin>>str;
    m=0;
    n=str.length();
    for (int i=0;i<n;i++)
    {
        r[i]=str[i]-'a'+1;
        m=max(r[i],m);
    }
    m++;
    da(r,sa,n,m);
    for (int i=0;i<n;i++)
        cout<<sa[i]<<" ";
    return 0;
}
```



## 后缀自动机

见jiangly模板

> `ALPHABET_SIZE` 字符集大小，仅处理小写英文字符的话是26
>
> `Node` 结构体：`len` 从根节点到当前节点所表示的最长字符串的长度
>
> ​						  `link` 指向当前节点的后缀链接
>
> ​						  `next` 当前节点在接受不同字符时能够到达的下一个节点的索引
>
> `t` vector存储所有结点 

使用jiangly的模板：





<div style="page-break-after: always;"></div>

# 数学

## 对数运算与e

`log(x)` 计算以e为底x的对数

`log2(x)` 计算以2为底x的对数

`log10(x)` 计算以10为底x的对数

`log(b)/log(a)` 计算其它对数需使用换底公式，计算以a为底b的对数

`exp(x)` 计算e的x次幂

`pow(x,y)` 计算x的y次幂

计算e：

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
main() {
	double ans=1.0;
	ll n,i,j,k,x;
	cout<<"位数:";
	cin>>x;
	cout<<"精度:";
	cin>>n;		//n越大越精确
	//cout<<jc(n);
	double t=1+1.0/n*1.0;
	for(i=1;i<=n;i++){//循环幂
		ans*=t;
	}
	 cout<<setprecision(x)<<fixed<<ans;
}
```



## 快速幂

计算a的b次方对p取模。

```c++
#include <iostream>
#include <algorithm>
using namespace std;
long long qpow(long long a,long long b,long long p)
{
   long long res = 1 ;
    while (b)
    {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

```



## 取模乘法和取模幂

```c++
long long mult_mod(long long a,long long b,long long c)		//计算ret=(a*b)%c a,b,c<2^63
{
	a%=c;
    b%=c;
    long long ret=0;
    long long tmp=a;
    while(b)
    {
    	if(b&1)
        {
        	ret+=tmp;
     		if(ret>c)ret-=c;		//直接取模慢很多
		}
 		tmp<<= 1;
 		if(tmp>c) tmp-=c;
		b>>=1;
 	}
 	return ret;
}
long long pow_mod(long long a,long long n,long long mod)		//计算ret=(a的n次方)%mod
{
	long long ret=1;
	long long temp=a%mod;
	while(n)
    {
		if(n&1)ret=mult_mod(ret,temp,mod);
		temp=mult_mod(temp,temp,mod);
		n>>=1;
	}
	return ret;
}
```



## 素数

### 埃氏筛

> 基本思想：如果一个数是质数，则它的倍数不是质数。

判断<MAXN的数是否为质数。notprime[i]值为false表示i是质数，为true表示i不是质数。

```c++
const int MAXN=1000010;
bool notprime[MAXN];
void init()
{
    memset(notprime,false,sizeof(notprime));
    notprime[0]=notprime[1]=true;
    for (int i=2;i<MAXN;i++)
    {
        if (!notprime[i])
        {
            if (i>MAXN/i) continue;		//不用i*i>MAXN，防止i*i溢出；也可开long long
            for (int j=i*i;j<MAXN;j+=i)
                notprime[j]=true;
        }
    }
}
```



### 欧拉筛

> 基本思想：如果一个数是质数，则它的倍数不是质数。（相比于埃氏筛，不重复筛选相同的数）

判断<=MAXN的数是否为质数。prime[0]为在此区间内质数个数，prime[i]为在此区间内的第i个质数。

```c++
const int MAXN=1000010;
int prime[MAXN+1];
void getPrime()
{
    memset(prime,0,sizeof(prime));
    for (int i=2;i<=MAXN;i++)
    {
        if (!prime[i]) prime[++prime[0]]=i;
        for (int j=1;j<=prime[0] && prime[j]<=MAXN/i;j++)
        {
            prime[prime[j]*i]=1;
            if (i%prime[j]==0) break;
        }
    }
}
```



### 大区间质数的二次筛选（埃氏筛+欧拉筛）例题：POJ2689

给出区间[L,U]，找出区间内相邻的质数中，距离最近的两个相邻质数、距离最远的两个相邻质数。

```c++
const int MAXN=100010;
int prime[MAXN+1];
void getPrime()
{
    memset(prime,0,sizeof(prime));
    for (int i=2;i<=MAXN;i++)
    {
        if (!prime[i]) prime[++prime[0]]=i;
        for (int j=1;j<=prime[0] && prime[j]<=MAXN/i;j++)
        {
            prime[prime[j]*i]=1;
            if (i%prime[j]==0) break;
        }
    }
}
bool notprime[MAXN];
int prime2[MAXN];
void getPrime2(int L,int R)
{
    memset(notprime,false,sizeof(notprime));
    if (L<2) L=2;
    for (int i=1;i<=prime[0] && (long long)prime[i]*prime[i]<=R;i++)
    {
        int s=L/prime[i]+(L%prime[i]>0);
        if (s==1) s=2;
        for (int j=s;(long long)j*prime[i]<=R;j++)
            if((long long)j*prime[i]>=L) notprime[j*prime[i]−L]=true;
    }
    prime2[0]=0;
    for (int i=0;i<=R-L;i++)
        if (!notprime[i]) prime2[++prime2[0]]=i+L;
}
int main()
{
    getPrime();
    int L,U;
    while (scanf("%d%d",&L,&U)==2)
    {
        getPrime2(L,U);
        if (prime2[0]<2)
            cout<<"There are no adjacent primes.\n";
        else
        {
            int x1=0,x2=100000000,y1=0,y2=0;
            for(int i=1;i<prime2[0];i++)
            {
                if (prime2[i+1]−prime2[i]<x2−x1)
                {
                    x1=prime2[i];
                    x2=prime2[i+1];
                }
                if ((prime2[i+1]−prime2[i]>y2−y1)
                   {
                    y1=prime2[i];
                    y2=prime2[i+1];
                }
            }
            printf("%d,%d are closest, %d,%d are most distant.\n",x1,x2,y1,y2);
        }
    }
	return 0;
}
```



### Miller-Rabin算法

> 原理：费马小定理：若n为质数且a与n互质，则有
> $$
> a^{n-1}\equiv1\;(\rm mod\;1)
> $$

给定x，判断x是否为质数。

**若x小于2的64次方，使用2,325,9375,28178,450775,9780504,1795265022替换随机生成的数可避免误判。**

```c++
#include<bits/stdc++.h>
using namespace std;
const int S=7;//随机算法判定次数,一般8～10就够了
long long s[7]={2LL,325LL,9375LL,28178LL,450775LL,9780504LL,1795265022LL};
long long mult_mod(long long a,long long b,long long c)		//计算ret=(a*b)%c a,b,c<2^63
{
	a%=c;
    b%=c;
    long long ret=0;
    long long tmp=a;
    while(b)
    {
    	if(b&1)
        {
        	ret+=tmp;
     		if(ret>c)ret-=c;		//直接取模慢很多
		}
 		tmp<<= 1;
 		if(tmp>c) tmp-=c;
		b>>=1;
 	}
 	return ret;
}
long long pow_mod(long long a,long long n,long long mod)		//计算ret=(a的n次方)%mod
{
	long long ret=1;
	long long temp=a%mod;
	while(n)
    {
		if(n&1)ret=mult_mod(ret,temp,mod);
		temp=mult_mod(temp,temp,mod);
		n>>=1;
	}
	return ret;
}
/*通过a的(n?1)次方=1(modn)来判断n是不是素数
n?1=x?2t中间使用二次判断
是合数返回true,不一定是合数返回false */
bool check(long long a,long long n,long long x,long long t)
{
	long long ret=pow_mod(a,x,n);
	long long last=ret;
	for(int i=1;i<=t;i++)
    {
		ret=mult_mod(ret,ret,n);
		if(ret==1 && last!=1 && last!=n-1) return true;//合数
		last=ret;
	}
	if(ret!=1) return true;
	else return false;
}
bool Miller_Rabin(long long n)
{
	if(n<2) return false;
	if(n==2) return true;
	if((n&1)==0) return false;//偶数
	long long x=n-1;
	long long t=0;
	while((x&1)==0) {x>>=1;t++;}
 	for(int i=0;i<S;i++)
    {

 		long long a =s[i];
 		if(a%n==0) continue;
		if(check(a,n,x,t)) return false;
	}
	return true;
}
int main()
{
    long long x;
    while(cin>>x)
    {
        if(Miller_Rabin(x)) cout<<"Y\n";
        else cout<<"N\n";
    }
}
```



### Meissel-Lehmer算法

计算不大于n的质数个数。

> 算法的时间复杂度为
> $$
> O(n^{2/3})
> $$
> 所以 n 的范围可以扩大至 1e12 的级别

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
//通过知道前面的 n^1/3 的质数可以推断后面n^2/3的质数所以可以适当减小
const int N  = 9e3;
const int M  = 2;         //为了减小内存可以不过是质数
const int PM = 2 * 3 * 5; //为了减小内存可以不过要按质数减小如去掉17
ll n;
bool np[N];
int prime[N], pi[N];
int phi[PM + 1][M + 1], sz[M + 1];
int getprime() {
    int cnt = 0;
    np[0] = np[1] = true;
    pi[0] = pi[1] = 0;
    for (int i = 2; i < N; ++i) {
        if (!np[i]) prime[++cnt] = i;
        pi[i] = cnt;
        for (int j = 1; j <= cnt && i * prime[j] < N; ++j) {
            np[i * prime[j]] = true;
            if (i % prime[j] == 0) break;
        }
    }
    return cnt;
}
void init() {
    getprime();
    sz[0] = 1;
    for (int i = 0; i <= PM; ++i) phi[i][0] = i;
    for (int i = 1; i <= M; ++i) {
        sz[i] = prime[i] * sz[i - 1];
        for (int j = 1; j <= PM; ++j) phi[j][i] = phi[j][i - 1] - phi[j / prime[i]][i - 1];
    }
}
int sqrt2(ll x) {
    ll r = (ll)sqrt(x - 0.1);
    while (r * r <= x) ++r;
    return int(r - 1);
}
int sqrt3(ll x) {
    ll r = (ll)cbrt(x - 0.1);
    while (r * r * r <= x) ++r;
    return int(r - 1);
}
ll getphi(ll x, int s) {
    if (s == 0) return x;
    if (s <= M) return phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];
    if (x <= prime[s] * prime[s]) return pi[x] - s + 1;
    if (x <= prime[s] * prime[s] * prime[s] && x < N) {
        int s2x = pi[sqrt2(x)];
        ll ans  = pi[x] - (s2x + s - 2) * (s2x - s + 1) / 2;
        for (int i = s + 1; i <= s2x; ++i) ans += pi[x / prime[i]];
        return ans;
    }
    return getphi(x, s - 1) - getphi(x / prime[s], s - 1);
}
ll getpi(ll x) {
    if (x < N) return pi[x];
    ll ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1;
    for (int i = pi[sqrt3(x)] + 1, ed = pi[sqrt2(x)]; i <= ed; ++i) ans -= getpi(x / prime[i]) - i + 1;
    return ans;
}
ll lehmer_pi(ll x) { //小于等于n的素数有多少个
    if (x < N) return pi[x];
    int a  = (int)lehmer_pi(sqrt2(sqrt2(x)));
    int b  = (int)lehmer_pi(sqrt2(x));
    int c  = (int)lehmer_pi(sqrt3(x));
    ll sum = getphi(x, a) + (ll)(b + a - 2) * (b - a + 1) / 2;
    for (int i = a + 1; i <= b; i++) {
        ll w = x / prime[i];
        sum -= lehmer_pi(w);
        if (i > c) continue;
        ll lim = lehmer_pi(sqrt2(w));
        for (int j = i; j <= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - 1);
    }
    return sum;
}
int main() {
    ios_base::sync_with_stdio(false), cin.tie(0);
    init();
    while (cin >> n && n) cout << lehmer_pi(n) << "\n";
    return 0;
}

```



## 欧拉函数

欧拉函数phi(n)=在1~n中与n互质的数的个数。

> 欧拉函数的性质：
> $$
> p为质数，k为正整数，m与n互质：\\
> \phi(p)=p-1\\
> \phi(p^k)=p^k-p^{k-1}\\
> \phi(mn)=\phi(m)\phi(n)
> $$

### 求单个数的欧拉函数

```c++
long long eular(long long n)
{
    long long ans=n;
    for (int i=2;i*i<=n;i++)
    {
        if (n%i==0)
        {
            ans-=ans/i;
            while (ans%i==0)
            {
                n/=i;
            }
        }
    }
    if (n>1) ans-=ans/n;
    return ans;
}
```



### 筛法欧拉函数

euler[i]=phi(i)

```c++
int euler[3000001];
void getEuler()
{
    memset(euler,0,sizeof(euler));
    euler[1]=1;
    for(int i=2;i<=3000000;i++)
    	if(!euler[i])
            for(int j=i;j<=3000000;j+=i)
            {
                if(!euler[j])
                    euler[j]=j;
                euler[j]=euler[j]/i*(i-1);
            }
}
```



### 线性筛求欧拉函数和质数表

同时得到MAXN以内的数的欧拉函数值和质数表。

```c++
const int MAXN=1e7;
bool check[MAXN+10];
int phi[MAXN+10];		//欧拉函数值
int prime[MAXN+10];		//质数表
int tot;				//质数个数
void phi_and_prime_table(int N)
{
    //memset(check,false,sizeof(check));
    phi[1]=1;
    tot=0;
    for (int i=2;i<=N;i++)
    {
        if (!check[i])
        {
            prime[tot++]=i;
            phi[i]=i-1;
        }
        for (int j=0;j<tot;j++)
        {
            if (i*prime[j]>N) break;
            check[i*prime[j]]=true;
            if( i%prime[j]==0)
            {
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			else
				phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
}
```



## 最大公约数(gcd)及乘法逆元

### 辗转相除法求gcd

```c++
long long gcd(long long a,long long b)
{
    return (b==0)?a:gcd(b,a%b);
}
```



### 扩展欧几里得算法

求解ax+by=gcd(a,b)及乘法逆元。extend_gcd()函数返回gcd(a,b)。mod_reverse返回ax=1(mod n)的解x。

```c++
long long extend_gcd(long long a,long long b,long long &x,long long &y)
{
    if (a==0 && b==0) return -1;
    if (b==0)
    {
        x=1;
        y=0;
        return a;
    }
    long long d=extend_gcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
long long mod_reverse(long long a,long long n)
{
    long long x,y;
    long long d=extend_gcd(a,n,x,y);
    if(d==1)
        return (x%n+n)%n;
    else
        return -1;
}
```

求逆元（ax=1(mod n)的解x）简洁写法：

**注意：简洁写法仅适用于a<m的情况，并且a与m必须互质。**

```c++
long long inv(long long a,long long m)
{
    if (a==1) return 1;
    return inv(m%a,m)*(m-m/a)%m;
}
```



## 逆元

### 扩展欧几里得算法

如上。



### 利用欧拉函数求逆元

**注意：m必须为质数，并且a与m必须互质。**

```c++
long long pow_m(long long a,long long n,long long mod)	//返回a的n次方%mod
{
    long long ret=1;
    long long tmp=a%mod;
    while (n)
    {
        if (n&1) ret=ret*tmp%mod;
        tmp=tmp*tmp%mod;
        n>>=1;
    }
    return ret;
}
long long inv(long long a,long long m)
{
    return pow_m(a,m-2,m);
}
```



## 模线性方程组

求解`X%m=a`方程组。m和a的值存放于m[]和a[]数组中。调用MLES()函数求解，无解返回false，有解返回true，解的最终形式为X=a0+m0*k。(其中，0<=a0<m0，k为任意非负整数)

```c++
long long extend_gcd(long long a,long long b,long long &x,long long &y)
{
    if (a==0 && b==0) return -1;
    if (b==0)
    {
        x=1;
        y=0;
        return a;
    }
    long long d=extend_gcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
const int N=10;		//方程个数
int m[N],a[N];
bool solve(int &m0,int &a0,int m,int a)
{
    long long y,x;
    int g=extend_gcd(m0,m,x,y);
    if (abs(a-a0)%g) return false;
    x*=(a-a0)/g;
    x%=m/g;
    a0=(x*m0+a0);
    m0*=m/g;
    a0%=m0;
    if (a0<0) a0+=m0;
    return true;
}
bool MLES(int &m0,int &a0,int n)
{
    bool flag=true;
    m0=1;
    a0=0;
    for (int i=0;i<n;i++)
    {
        if (!solve(m0,a0,m[i],a[i]))
        {
            flag=false;
            break;
        }
    }
    return flag;
}
```



## 高斯消元法

### 解参数为浮点数的线性方程组

方程参数为double型，eps为计算精度（即两数差小于eps时视作相等）。数组a的前n列存放方程组左边系数，第n+1列存放等式右边的值。数组x[]存放求得的解。equ为方程个数，var为未知数个数。Guss()函数在有解时返回1，无解时返回0.

```c++
#define eps 1e-9
const int MAXN=220;
double a[MAXN][MAXN],x[MAXN];
int equ,var;
int Guss()
{
    int i,j,k,col,max_r;
    for (k=0,col=0;k<equ && col<val;k++,col++)
    {
        max_r=k;
        for(i=k+1;i<equ;i++)
            if(fabs(a[i][col])>fabs(a[max_r][col]))
                max_r=i;
        if(fabs(a[max_r][col])<eps) return 0;
        if (k!=max_r)
        {
            for (j=col;j<var;j++)
                swap(a[k][j],a[max_r][j]);
            swap(x[k],x[max_r]);
        }
        x[k]/=a[k][col];
        for(j=col+1;j<var;j++)
            a[k][j]/=a[k][col];
        a[k][col]=1;
        for(i=0;i<equ;i++)
            if (i!=k)
            {
                x[i]-=x[k]*a[i][col];
                for(j=col+1;j<var;j++)
                    a[i][j]-=a[k][j]*a[i][col];
                a[i][col]=0;
            }
    }
    return 1;
}
```



### 解同余方程组

a数组为增广矩阵，mod为模数，equ为方程个数，var为未知数个数。gauss()函数在无解时返回-1，多解时返回自由变元个数，有唯一解时返回0，x[]数组存储解。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN=220;
int a[MAXN][MAXN],x[MAXN];
int equ,var;
int mod;
long long extend_gcd(long long a,long long b,long long &x,long long &y)
{
    if (a==0 && b==0) return -1;
    if (b==0)
    {
        x=1;
        y=0;
        return a;
    }
    long long d=extend_gcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}
long long inv(long long a,long long m)
{
    if(a==1) return 1;
    return inv(m%a,m)*(m-m/a)%m;
}
inline int gcd(int a,int b)
{
    return (b==0)?a:gcd(b,a%b);
}
inline int getlcm(int a,int b)
{
    return a*b/gcd(a,b);
}
int gauss()
{
    int i,j,k;
    int max_r,col;
    int ta,tb,lcm;
    int tmp;
    for(k=0,col=0;k<equ && col<var;k++,col++)
    {
        max_r=k;
        for(i=k+1;i<equ;i++)
            if(abs(a[i][col])>abs(a[max_r][col]))
                max_r=i;
        if(a[max_r][col]==0)
        {
            k--;
            continue;
        }
        if(k!=max_r)
            for(j=col;j<var+1;j++)
                swap(a[k][j],a[max_r][j]);
        for(i=k+1;i<equ;i++)
            if(a[i][col]!=0)
            {
                lcm=getlcm(abs(a[i][col]),abs(a[k][col]));
                ta=lcm/abs(a[i][col]);
                tb=lcm/abs(a[k][col]);
                if(a[i][col]*a[k][col]<0) tb=-tb;
                for(j=col;j<var+1;j++)
                    a[i][j]=((a[i][j]*ta-a[k][j]*tb)%mod+mod)%mod;
            }
    }
    for(i=k;i<equ;i++)
        if(a[i][col]!=0)
            return -1;
    if(k<var) return var-k;
    for(i=var-1;i>=0;i--)
    {
        tmp=a[i][var];
        for(j=i+1;j<var;j++)
            if(a[i][j]!=0)
            {
                tmp-=a[i][j]*x[j];
                tmp=(tmp%mod+mod)%mod;
            }
        x[i]=(tmp*inv(a[i][i],mod))%mod;
    }
    return 0;
}
```



### 对2取模的01方程组

a数组为增广矩阵，equ为方程个数，var为未知数个数。Gauss()函数在无解时返回-1，多解时返回自由变元个数，有唯一解时返回0，x[]数组存储解，free_num存储自由变元数量，free_x[]数组存储自由变元。

```c++
const int MAXN=300;
int equ,var;
int a[MAXN][MAXN];
int x[MAXN];
int free_x[MAXN];
int free_num;
int Gauss()
{
    int max_r,col,k;
    free_num=0;
    for(k=0,col=0;k<equ && col<var;k++,col++)
    {
        max_r=k;
        for(int i=k+1;i<equ;i++)
            if(abs(a[i][col])>abs(a[max_r][col])) max_r=i;
        if(a[max_r][col]==0)
        {
            k--;
            free_x[free_num++]=col;
            continue;
        }
        if(max_r!=k)
            for(int j=col;j<var+1;j++)
                swap(a[k][j],a[max_r][j]);
        for(int i=k+1;i<equ;i++)
            if(a[i][col]!=0)
                for(int j=col;j<var+1;j++)
                    a[i][j]^=a[k][j];
    }
    for(int i=k;i<equ;i++)
        if(a[i][col]!=0) return -1;
    if(k<var)
        return var-k;
    for(int i=var-1;i>=0;i--)
    {
        x[i]=a[i][var];
        for(int j=i+1;j<var;j++)
            x[i]^=(a[i][j]&&x[j]);
    }
    return 0;
}
```



## 快速傅里叶变换(FFT)

### 高精度乘法

使用FFT高精度计算两个大数乘积。有若干组数据，每次输入两个数，输出它们的乘积。

```c++
#include<bits/stdc++.h>
using namespace std;
//complex是stl自带的定义复数的容器 
typedef complex<double> cp;
#define N 2097153
//pie表示圆周率π 
const double pie=acos(-1);
int n;
cp a[N],b[N];
long long rev[N],ans[N];
string s1,s2;
//读入优化 
int read(){
	int sum=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum*f;
}
//初始化每个位置最终到达的位置
void init(int k) 
{
    int len=1<<k;
	for(int i=0;i<len;i++)
	rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
}
//a表示要操作的系数，n表示序列长度
//若flag为1，则表示FFT，为-1则为IFFT(需要求倒数） 
void fft(cp *a,int n,int flag){ 
    for(int i=0;i<n;i++)
	{
	 //i小于rev[i]时才交换，防止同一个元素交换两次，回到它原来的位置。 
	  if(i<rev[i])swap(a[i],a[rev[i]]);
	}
	for(int h=1;h<n;h*=2)//h是准备合并序列的长度的二分之一
	{
	cp wn=exp(cp(0,flag*pie/h));//求单位根w_n^1 
	 for(int j=0;j<n;j+=h*2)//j表示合并到了哪一位
	 {
	  cp w(1,0);
	   for(int k=j;k<j+h;k++)//只扫左半部分，得到右半部分的答案
	   {
	     cp x=a[k];
	     cp y=w*a[k+h];
         a[k]=x+y;  //这两步是蝴蝶变换 
         a[k+h]=x-y;
         w*=wn; //求w_n^k 
	   }
	 }
	 }
	 //判断是否是FFT还是IFFT 
	 if(flag==-1)
	 for(int i=0;i<n;i++)
     a[i]/=n;
}
int main(){
//	n=read(); 
	cin>>s1>>s2;
	int n1=s1.length(),n2=s2.length();
	//读入的数的每一位看成多项式的一项，保存在复数的实部 
    for(int i=0;i<n1;i++)a[i]=(double)(s1[n1-i-1]-'0');
	for(int i=0;i<n2;i++)b[i]=(double)(s2[n2-i-1]-'0');
	//k表示转化成二进制的位数 
	int k=0,s=1;
 	while(s<n1+n2)k++,s<<=1;
	init(k);
	//FFT 把a的系数表示转化为点值表示 
    fft(a,s,1);
    //FFT 把b的系数表示转化为点值表示 
    fft(b,s,1);
    //FFT 两个多项式的点值表示相乘 
    for(int i=0;i<s;i++)
    a[i]*=b[i];
    //IFFT 把这个点值表示转化为系数表示 
    fft(a,s,-1);
    //保存答案的每一位(注意进位） 
    for(int i=0;i<s;i++)
    {
    //取实数四舍五入，此时虚数部分应当为0或由于浮点误差接近0
	ans[i]+=(int)(a[i].real()+0.5);
	ans[i+1]+=ans[i]/10;
	ans[i]%=10;
	}
	s=n1+n2+1;
	while(ans[s]){//还有前面没有处理的
		ans[s+1]+=ans[s]/10;
		ans[s]%=10;
		s++;
	}
	while(!ans[s]&&s>-1)s--;
	if(s==-1)printf("0");
	else
	for(int i=s;i>=0;i--)
	printf("%d",ans[i]);
	return 0;
}
```



## 杜教筛

用于求数论函数（必须是积性函数）的前缀和。例如求莫比乌斯函数和欧拉函数的前缀和。

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <map>
using namespace std;
const int maxn = 2000010;
long long T, n, pri[maxn], cur, mu[maxn], sum_mu[maxn];
bool vis[maxn];
map<long long, long long> mp_mu;
long long S_mu(long long x) {  // 求mu的前缀和
  if (x < maxn) return sum_mu[x];
  if (mp_mu[x]) return mp_mu[x];  // 如果map中已有该大小的mu值，则可直接返回
  long long ret = (long long)1;
  for (long long i = 2, j; i <= x; i = j + 1) {
    j = x / (x / i);
    ret -= S_mu(x / i) * (j - i + 1);
  }
  return mp_mu[x] = ret;  // 路径压缩，方便下次计算
}

long long S_phi(long long x) {  // 求phi的前缀和
  long long ret = (long long)0;
  long long j;
  for (long long i = 1; i <= x; i = j + 1) {
    j = x / (x / i);
    ret += (S_mu(j) - S_mu(i - 1)) * (x / i) * (x / i);
  }
  return (ret - 1) / 2 + 1;
}
int main() {
  scanf("%lld", &T);
  mu[1] = 1;
  for (int i = 2; i < maxn; i++) {  // 线性筛预处理mu数组
    if (!vis[i]) {
      pri[++cur] = i;
      mu[i] = -1;
    }
    for (int j = 1; j <= cur && i * pri[j] < maxn; j++) {
      vis[i * pri[j]] = true;
      if (i % pri[j])
        mu[i * pri[j]] = -mu[i];
      else {
        mu[i * pri[j]] = 0;
        break;
      }
    }
  }
  for (int i = 1; i < maxn; i++)
    sum_mu[i] = sum_mu[i - 1] + mu[i];  // 求mu数组前缀和
  while (T--) {
    scanf("%lld", &n);
    printf("%lld %lld\n", S_phi(n), S_mu(n));
  }
  return 0;
}
```

## 多项式乘法（DFT)

```c++
#include <bits/stdc++.h>
using namespace std;

using LL=long long;
using LD=long double;
using UI=unsigned int;
using ULL=unsigned long long;

constexpr int MOD=998244353,G=114514,MAXN=1<<21;
inline int qpow(LL x,LL y) { LL r=1;for(;y;y>>=1,x=x*x%MOD)if(y&1)r=r*x%MOD;return r; }
inline int madd(int x) { return x; }
inline int mmul(int x) { return x; }
inline int msub(int x,int y) { return (x-=y)<0?x+=MOD:x; }
inline int mdiv(int x,int y) { return (LL)x*qpow(y,MOD-2)%MOD; }
template<typename ...T> inline int madd(int x,T ...y) { return (x+=madd(y...))>=MOD?x-=MOD:x; }
template<typename ...T> inline int mmul(int x,T ...y) { return (LL)x*mmul(y...)%MOD; }

int g[MAXN];
inline int fix(int m)
{ return m<=1?1:(1<<(__lg(m-1)+1)); }
void prework()
{
	for(int i=1;i<MAXN;i<<=1)
	{
		g[i]=1;
		int gn=qpow(G,(MOD-1)/(i<<1));
		for(int j=i+1;j<(i<<1);j++) g[j]=mmul(g[j-1],gn);
	}
}
void DFT(int *a,int len)
{
	int x,y;
	for(int i=(len>>1);i;i>>=1)
		for(int j=0;j<len;j+=(i<<1))
			for(int k=0;k<i;k++)
				x=a[j+k],y=a[i+j+k],a[j+k]=madd(x,y),a[i+j+k]=mmul(g[i+k],msub(x,y));
}
void IDFT(int *a,int len)
{
	int x,y;
	for(int i=1;i<len;i<<=1)
		for(int j=0;j<len;j+=(i<<1))
			for(int k=0;k<i;k++)
				x=a[j+k],y=mmul(g[i+k],a[i+j+k]),a[j+k]=madd(x,y),a[i+j+k]=msub(x,y);
	x=qpow(len,MOD-2);
	reverse(a+1,a+len);
	for(int i=0;i<len;i++) a[i]=mmul(a[i],x);
}

int n,m,a[MAXN+5],b[MAXN+5];

int main()
{
#ifndef DADALZY
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
#endif
	prework();
	cin>>n>>m,n++,m++;
	for(int i=0;i<n;i++) cin>>a[i];
	for(int i=0;i<m;i++) cin>>b[i];
	int nn=fix(n+m-1);
	DFT(a,nn),DFT(b,nn);
	for(int i=0;i<nn;i++) a[i]=mmul(a[i],b[i]);
	IDFT(a,nn);
	for(int i=0;i<n+m-1;i++) cout<<a[i]<<' ';
	cout<<'\n';
	return 0;
}
```



## 佩尔方程

满足如下形式的方程，称为佩尔方程。
$$
x^2-dy^2=t
$$
连分数法求解方程最小解x,y

```c++
#include<bits/stdc++.h>
using namespace std;
int a[20000];
bool pell(int &x,int &y,int d){
    int m=(int)sqrt((double)d);
    if(m*m==d)//d不能为完全平方数
        return false;
 
    //将d以连分数形式存储
    int num=0;//连分数数位
    double sq=sqrt(d);//d的高精度根，相当于r0
    a[num++]=m;//存储整数部分
    int b=m;//当前整数部分
    int c=1;//连分数最终展开时的分母
    double temp;//连分数展开时的每一项
    do{
        c=(d-b*b)/c;
        temp=(sq+b)/c;
        a[num++]=(int)(floor(temp));
        b=a[num-1]*c-b;
    }while(a[num-1]!=2*a[0]);//当有一位等于整数两倍时结束
 
    //将连分数形式化为分子分母形式，即求p、q两个值
    int p=1,q=0;
    for(int i=num-2;i>=0;i--){
        int temp=p;
        p=q+p*a[i];
        q=temp;
    }
 
    if((num-1)%2){//连分数长度为奇数时
        x=2*p*p+1;
        y=2*p*q;
    }
    else{//连分数长度为偶数时
        x=p;
        y=q;
    }
    return true;
}
int main(){
    int d;
    while(scanf("%d",&d)!=EOF){
        int x,y;
        if(pell(x,y,d))
            cout<<x<<" "<<y<<endl;
        else
            cout<<"No Solution"<<endl;
    }
    return 0;
}
```

## 求矩阵的行列式的值

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

#define N 600
#define M 998244353

int i,j,k,n,m,t;
vector<int> v[N+5];
ll invp;

inline int mod(ll x){
	return x - (__int128(x) * invp >> 64) * M;
}

ll hls(int n){
	int i,j,k,d;
	ll res=1;
	for(i=1;i<=n;i++){
		for(j=i+1;j<=n;j++){
			while(v[i][i]){
				d=v[j][i]/v[i][i];
				if(d)for(k=i;k<=n;k++){
					v[j][k]=mod(v[j][k]-1ll*v[i][k]*d);
				}
				swap(v[i],v[j]); res=M-res;
			}
			swap(v[i],v[j]); res=M-res;
		}
		res=res*v[i][i]%M;
		if(!res)break;
	}
	return res;
}

int main(){
	ios::sync_with_stdio(0); cin.tie(0);
	cin>>n;
	invp = (__int128(1) << 64) / M + 1;
	for(i=1;i<=n;i++){
		v[i].resize(n+1);
		for(j=1;j<=n;j++)cin>>v[i][j];
	}
	cout<<hls(n);
}
```



# 数据结构

## 区间合并

给定n个区间，将其合并，以pair形式将合并后的若干个区间存储于`vector<PII> segs`中。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
const int N = 100010;
vector<PII> segs;
int n;
//区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;//用来存储
    //按区间的左端点来进行排序，然后再按照第二个排序（pair很像）
    sort(segs.begin(),segs.end());
    //将st(start)和ed(end)初始化为负无穷，确保端点一定在左面
    int st = -2e9, ed = -2e9;
    for(auto seg : segs)
    {
        //如果比较区间的左端点不在当前区间中
        if(ed < seg.first)
        {
            //判断一下是否更新 新的当前区间（以防第一次更新）
            if(st!=-2e9) res.push_back({st,ed});
            st = seg.first,ed = seg.second;//更新区间，变成当前区间
        }
        //如果比较区间的左端点在区间中更新一下最大的右端点
        else
            ed = max(ed,seg.second); 
    }
    //看一下，最后一个元素是否被合并
    if(st!=-2e9) res.push_back({st,ed});
    segs = res;
}
int main()
{
    cin >> n;
    //存入坐标
    for(int i=0;i<n;i++)
    {
        int l,r;
        cin >> l >> r;
        /****************
        用于数轴循环的情况，例如数轴最大为86400，r<l意味着跨过86400与0的连接位置，拆分为两个区间来处理
        if(r<l) 
        {
        	segs.push_back({0,r});
        	segs.push_back({l,86400});
		}
        else
        	segs.push_back({l,r});
        ****************/
        segs.push_back({l,r});
    }
    //区间合并
    merge(segs);
    cout << segs.size() << endl;	//输出合并后的区间个数
    return 0;
}
```



## 并查集

用于合并两集合、判断两元素是否在同一集合中。pre[i]表示结点i的根结点。

**注意：并查集不支持分割一个集合。**

```c++
const int MAXN=1e5;
int pre[MAXN];
int unionsearch(int root)		//查找根结点
{
	int son,tmp;
	son=root;
	while(root!=pre[root])
		root=pre[root];
	while(son!=root)
	{
		tmp=pre[son];
		pre[son]=root;
		son=tmp;
	}
	return root;
}
void join(int root1,int root2)	//root1和root2所在的集合合并
{
	int x,y;
	x=unionsearch(root1);
	y=unionsearch(root2);
	if(x!=y) 
		pre[x]=y;
}
```



## 划分树

进行m次查询，每次查询给定查询区间[s,t]，查找区间内第k大的元素。二维数组tree存储划分树，`tree[i][j]`(i>=0,j>=1)表示划分树第i层的第j个元素的值，因此，初识数组存储在`tree[0][]`中。sorted[]数组储存经排序后的初始序列。query()函数参数L,R是大区间，l,r是查询区间，查询第k大的值。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxN = 1e5 + 5;
int N, M, T;
int tree[20][maxN];
int sorted[maxN];
int toLeft[20][maxN];
void build(int l, int r, int dep)
{
    if (l == r) return;
    int mid = (l + r) >> 1;
    int same = mid - l + 1;
    int smid = sorted[mid];
    for (int i=l,i<=r;i++)
        if (tree[dep][i]<smid)
            --same;

    int lpos = l, rpos = mid + 1;
    for (int i=l,i<=r;i++)
    {
        if (tree[dep][i] < smid)
            tree[dep + 1][lpos++] = tree[dep][i];
        else if (tree[dep][i] == smid && same > 0)
        {
            --same;
            tree[dep + 1][lpos++] = tree[dep][i];
        }
        else
            tree[dep + 1][rpos++] = tree[dep][i];
        toLeft[dep][i] = toLeft[dep][l - 1] + lpos - l;
    }
    build(l, mid, dep + 1);
    build(mid + 1, r, dep + 1);
}
// L R是大区间 l,r是查询区间,查询第k大值
int query(int L,int R,int l,int r,int dep,int k)
{
    if (l==r) return tree[dep][l];
    int mid=(L+R)>>1;
    int cnt=toLeft[dep][r]-toLeft[dep][l-1];
    if (cnt>=k)
    {
        int newl = L + toLeft[dep][l - 1] - toLeft[dep][L - 1];
        int newr = newl + cnt - 1;
        return query(L, mid, newl, newr, dep + 1, k);
    }
    else
    {
        int newr = r + toLeft[dep][R] - toLeft[dep][r];
        int newl = newr - (r - l - cnt);
        return query(mid + 1, R, newl, newr, dep + 1, k - cnt);
    }
}
int main()
{
    scanf("%d%d",&N,&M);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&tree[0][i]);
        sorted[i]=tree[0][i];
    }
    sort(sorted+1,sorted+1+N);
    build(1,N,0);
    int s,t,k;
    for (int i=0;i<M;i++)
    {
        scanf("%d%d%d",&s,&t,&k);
        printf("%d\n",query(1,N,s,t,0,k));
    }
    return 0;
}
```



## 树状数组

**注意：树状数组维护的信息必须满足结合律，例如加法求和。**

### 一维

BITree[y]为BITree[x]的父结点，当且仅当y=x-lowbit(x)。BITree[0]为根结点，其值为0。除了根结点以外的父结点元素值等于其所有子结点元素值之和。

操作1：a[l...r]各元素加val；

操作2：查询a[l...r]各元素之和；

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MaxN = (int)1e6;
int N;
ll A[MaxN + 5];
ll s1[MaxN + 5], s2[MaxN + 5];
inline int lowbit(int x) {return x & (-x);}
inline void modify(int pos, ll val) {
    for(int i = pos; i <= N; i += lowbit(i))
        s1[i] += val, s2[i] += pos * val;
}
inline void modify(int l, int r, ll val) {
    modify(l, val), modify(r + 1, -val);
}
inline ll query(int x) {
    ll ret = 0;
    for(int i = x; i >= 1; i -= lowbit(i))
        ret += (x + 1) * s1[i] - s2[i];
    return ret;
}
inline ll query(int l, int r) {
    return query(r) - query(l - 1);
}
int main() {
    int M;
    scanf("%d %d", &N, &M);
    for(int i = 1; i <= N; i++)
        scanf("%lld", &A[i]);
    for(int i = 1; i <= N; i++)
        modify(i, A[i] - A[i - 1]);
    for(int i = 1; i <= M; i++) {
        int opt;
        scanf("%d", &opt);
        if(opt == 1) {
            int l, r, val;
            scanf("%d %d %d", &l, &r, &val);
            modify(l, r, val);
        }
        if(opt == 2) {
            int l, r;
            scanf("%d %d", &l, &r);
            printf("%lld\n", query(l, r));
        }
    }
    return 0;
}
```



### 二维

操作D：(x1,y1)到(x2,y2)矩形区域内各元素加k；

操作Q：查询(x1,y1)到(x2,y2)矩形区域内各元素之和。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn =2050*2;
int n, m,q;
ll t1[maxn][maxn], t2[maxn][maxn], t3[maxn][maxn], t4[maxn][maxn];
int lowbit(int x) { return x & -x; }
void update(int x, int y, ll val) {
    for (int i = x; i <= n; i += lowbit(i)) {
        for (int j = y; j <= m; j += lowbit(j)) {
            t1[i][j] += val;
            t2[i][j] += val * x;
            t3[i][j] += val * y;
            t4[i][j] += val * x * y;
        }
    }
}
ll query(int x, int y) {  
    ll res = 0;
    for (int i = x; i > 0; i -= lowbit(i)) {
        for (int j = y; j > 0; j -= lowbit(j)) {
            res += t1[i][j] * (x + 1) * (y + 1) - t2[i][j] * (y + 1) - t3[i][j] * (x + 1) + t4[i][j];
        }
    }
    return res;
}
void solve() {
    cin >> n >> m >>q;
   char op[2];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            int x;
            cin>>x;
            update(i, j, x);
            update(i + 1, j + 1, x);
            update(i, j + 1, -x);
            update(i + 1, j, -x);
        }
    }
   for(int i=0;i<q;i++) {
     cin>>op;
        if (op[0] == 'D') {
            int a, b, c, d;
            ll k;
            cin >> a >> b >> c >> d >> k;
            update(a, b, k);
            update(c + 1, d + 1, k);
            update(a, d + 1, -k);
            update(c + 1, b, -k);
        } else {
            int a, b, c, d;
            cin >> a >> b >> c >> d;
            cout << query(c, d) - query(a - 1, d) - query(c, b - 1) + query(a - 1, b - 1) << "\n";
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    solve();
    return 0;
}
```



## 线段树

**注意：开数组储存建立的线段树时，要开4*n的空间防止下标越界。**

**注意：输入区间的两个下标大小可能相反。**

### 区间和

二维区间和可使用前缀和方法求解（见上文）。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
int a[maxn+2];
struct tree{
    int l,r;
    long long pre,add;      //pre为区间和，add为lazy标记
}t[4*maxn+2];
void bulid(int p,int l,int r)
{
    t[p].l=l;t[p].r=r;
    if(l==r){
        t[p].pre=a[l];
        return;
    }
    int mid=l+r>>1;
    bulid(p*2,l,mid);
    bulid(p*2+1,mid+1,r);
    t[p].pre=t[p*2].pre+t[p*2+1].pre;
}
void spread(int p)          //传递lazy标记
{
    if(t[p].add){
        t[p*2].pre+=t[p].add*(t[p*2].r-t[p*2].l+1);
        t[p*2+1].pre+=t[p].add*(t[p*2+1].r-t[p*2+1].l+1);
        t[p*2].add+=t[p].add;
        t[p*2+1].add+=t[p].add;
        t[p].add=0;
    }
}
void change(int p,int x,int y,int z)    //区间修改
{
    if(x<=t[p].l && y>=t[p].r){
        t[p].pre+=(long long)z*(t[p].r-t[p].l+1);
        t[p].add+=z;
        return;
    }
    spread(p);
    int mid=t[p].l+t[p].r>>1;
    if(x<=mid) change(p*2,x,y,z);
    if(y>mid) change(p*2+1,x,y,z);
    t[p].pre=t[p*2].pre+t[p*2+1].pre;
}
long long ask(int p,int x,int y)        //区间查询（区间和）
{
    if(x<=t[p].l && y>=t[p].r) return t[p].pre;
    spread(p);
    int mid=t[p].l+t[p].r>>1;
    long long ans=0;
    if(x<=mid) ans+=ask(p*2,x,y);
    if(y>mid) ans+=ask(p*2+1,x,y);
    return ans;
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    bulid(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int q,x,y,z;
        scanf("%d",&q);
        if(q==1)
        {
            scanf("%d%d%d",&x,&y,&z);
            change(1,x,y,z);
        }
        else {
            scanf("%d%d",&x,&y);
            cout<<ask(1,x,y)<<endl;
        }
    }
    return 0;
}
```



### 区间和与乘积

需要维护两个标记，此例中为`add`和`mul`。

```c++
#include <bits/stdc++.h>
#define MAXN 100010
#define ll long long
using namespace std;
int n, m, mod;
int a[MAXN];
struct Segment_Tree{
	ll sum, add, mul;
	int l, r;
}s[MAXN * 4];
void update(int pos)
{
	s[pos].sum = (s[pos << 1].sum + s[pos << 1 | 1].sum) % mod;
    return;
}
void pushdown(int pos)
{
	s[pos << 1].sum = (s[pos << 1].sum * s[pos].mul + s[pos].add * (s[pos << 1].r - s[pos << 1].l + 1)) % mod;
	s[pos << 1 | 1].sum = (s[pos << 1 | 1].sum * s[pos].mul + s[pos].add * (s[pos << 1 | 1].r - s[pos << 1 | 1].l + 1)) % mod;
	s[pos << 1].mul = (s[pos << 1].mul * s[pos].mul) % mod;
	s[pos << 1 | 1].mul = (s[pos << 1 | 1].mul * s[pos].mul) % mod;
	s[pos << 1].add = (s[pos << 1].add * s[pos].mul + s[pos].add) % mod;
	s[pos << 1 | 1].add = (s[pos << 1 | 1].add * s[pos].mul + s[pos].add) % mod;
	s[pos].add = 0;
	s[pos].mul = 1;
	return; 
}
void build_tree(int pos, int l, int r)
{
	s[pos].l = l;
	s[pos].r = r;
	s[pos].mul = 1;
	if (l == r)
    {
		s[pos].sum = a[l] % mod;
		return;
	}
	int mid = (l + r) >> 1;
	build_tree(pos << 1, l, mid);
	build_tree(pos << 1 | 1, mid + 1, r);
	update(pos);
	return;
}
void ChangeMul(int pos, int x, int y, int k)	//区间修改（乘法）
{
	if (x <= s[pos].l && s[pos].r <= y) {
		s[pos].add = (s[pos].add * k) % mod;
		s[pos].mul = (s[pos].mul * k) % mod;
		s[pos].sum = (s[pos].sum * k) % mod;
		return;
	}
	pushdown(pos);
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) ChangeMul(pos << 1, x, y, k);
	if (y > mid) ChangeMul(pos << 1 | 1, x, y, k);
	update(pos);
	return;
}
void ChangeAdd(int pos, int x, int y, int k)	//区间修改（加法）
{
	if (x <= s[pos].l && s[pos].r <= y) {
		s[pos].add = (s[pos].add + k) % mod;
		s[pos].sum = (s[pos].sum + k * (s[pos].r - s[pos].l + 1)) % mod;
		return;
	}
	pushdown(pos);
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) ChangeAdd(pos << 1, x, y, k);
	if (y > mid) ChangeAdd(pos << 1 | 1, x, y, k);
	update(pos);
	return;
}
ll AskRange(int pos, int x, int y)			//区间查询
{
	if (x <= s[pos].l && s[pos].r <= y) {
		return s[pos].sum;
	}
	pushdown(pos);
	ll val = 0;
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) val = (val + AskRange(pos << 1, x, y)) % mod;
	if (y > mid) val = (val + AskRange(pos << 1 | 1, x, y)) % mod;
	return val;
}
int main()
{
	scanf("%d%d%d", &n, &m, &mod);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	build_tree(1, 1, n);
	for (int i = 1; i <= m; i++) {
		int opt, x, y;
		scanf("%d%d%d", &opt, &x, &y);
		if (opt == 1) {
			int k;
			scanf("%d", &k);
			ChangeMul(1, x, y, k);
		}
		if (opt == 2) {
			int k;
			scanf("%d", &k);
			ChangeAdd(1, x, y, k);
		}
		if (opt == 3) {
			printf("%lld\n", AskRange(1, x, y));
		}
	}
	return 0;
}
```



### 区间和,区间积与区间幂之和

操作1：a[x...y]各元素加k；

操作2：a[x...y]各元素乘k；

操作3：a[x...y]各元素改为k；（通过乘0加k实现）

操作4：计算a[x...y]各元素的p次幂之和。

```c++
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
#pragma GCC optimize(2)
using namespace std;
const int N=4e5+10,MOD=10007,T=4;//T代表幂次 8s极限
typedef long long LL;
struct Tree
{
    int l,r;
    int sum[T+1],add,mul;
    void init()
    {
        l=r=add=0;
        memset(sum,0,sizeof(sum));
        mul=1;
        return ;
    }
}tree[N];
int cnt;
int n,m;
int C[T+2][T+2];    //组合数C[i][j]
void zxc()  //计算组合数
{
    for(int i=0;i<=T;i++)
    {
        for(int j=0;j<=i;j++)
        {
            if(j==0)
            {
                C[i][j]=1;
            }
            else
            {
                C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
            }
        }
    }
    return ;
}
int new_node()
{
    int x=++cnt;
    tree[x].init();
    return x;
}
void pushup(int x)
{
    for(int i=0;i<=T;i++)
        tree[x].sum[i]=((LL)tree[tree[x].l].sum[i]+tree[tree[x].r].sum[i])%MOD;
    return ;
}
void calc(int x,int mul,int add)
{
    int sum[T+1];
    int m_mul[T+1];
    int m_add[T+1];
    memcpy(sum,tree[x].sum,sizeof(tree[x].sum));
    m_mul[0]=m_add[0]=1;
    for(int i=1;i<=T;i++)
    {
        m_mul[i]=((LL)m_mul[i-1]*mul)%MOD;
        m_add[i]=((LL)m_add[i-1]*add)%MOD;
    }
    for(int t=0;t<=T;t++)
    {
        tree[x].sum[t]=0;
        for(int i=t;i>=0;i--)
        {
            tree[x].sum[t]=((LL)tree[x].sum[t]+(LL)C[t][i]*sum[i]%MOD*m_mul[i]*m_add[t-i]%MOD)%MOD;
        }
    }
    tree[x].mul=((LL)tree[x].mul*mul)%MOD;
    tree[x].add=((LL)tree[x].add*mul+add)%MOD;
    return ;
}
void pushdown(int x)
{
    if(tree[x].mul==1&&tree[x].add==0)
        return ;
    calc(tree[x].l,tree[x].mul,tree[x].add);
    calc(tree[x].r,tree[x].mul,tree[x].add);
    tree[x].mul=1;
    tree[x].add=0;
    return ;
}
int val[N];
int build(int l,int r)
{
    int x=new_node();
    if(l==r)
    {
        tree[x].sum[0]=1;
        return x;
    }
    int mid=(l+r)>>1;
    tree[x].l=build(l,mid);
    tree[x].r=build(mid+1,r);
    pushup(x);
    return x;
}
void modify(int x,int l,int r,int ql,int qr,int mul,int add)
{
    if(l==ql&&r==qr)
    {
        calc(x,mul,add);
        return ;
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(qr<=mid)
        modify(tree[x].l,l,mid,ql,qr,mul,add);
    else if(ql>=mid+1)
        modify(tree[x].r,mid+1,r,ql,qr,mul,add);
    else
    {
        modify(tree[x].l,l,mid,ql,mid,mul,add);
        modify(tree[x].r,mid+1,r,mid+1,qr,mul,add);
    }
    pushup(x);
    return ;
}
int query(int x,int l,int r,int ql,int qr,int type)
{
    if(l==ql&&r==qr)
    {
        return tree[x].sum[type];
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(qr<=mid)
        return query(tree[x].l,l,mid,ql,qr,type);
    else if(ql>=mid+1)
        return query(tree[x].r,mid+1,r,ql,qr,type);
    else
    {
        return ((LL)query(tree[x].l,l,mid,ql,mid,type)+query(tree[x].r,mid+1,r,mid+1,qr,type))%MOD;
    }
}
int root=0;
int main()
{
    zxc();
    while(scanf("%d%d",&n,&m)==2)
    {
        if(n==0&&m==0)
            break;
        cnt=0;
        int root=build(1,n);
        for(int i=1;i<=m;i++)
        {
            int opt;
            scanf("%d",&opt);
            int l,r,c;
            scanf("%d%d%d",&l,&r,&c);
            if(opt==1)
            {
                modify(root,1,n,l,r,1,c);
            }
            else if(opt==2)
            {
                modify(root,1,n,l,r,c,0);
            }
            else if(opt==3)
            {
                modify(root,1,n,l,r,0,c);
            }
            else
            {
                printf("%d\n",query(root,1,n,l,r,c));
            }
        }
    }
    return 0;
}
```



### 区间根号和

操作0：将ship[x...y]各元素开根号向下取整；

操作1：查询ship[x..y]各元素之和。

因为多次开根号向下取整后容易变为1，因此当某结点存储的sum等于维护的区间的元素个数意味着下面的各元素都为1，无需再更新。

```c++
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 1e5+5;
int n,m,ind;
ll ship[MAXN];
struct Tree
{
	int l,r;
	ll sum;
}tree[4*MAXN];
void Build(int i,int l,int r)
{
	tree[i].l = l;
	tree[i].r = r;
	if(l == r)
	{
		tree[i].sum = ship[l];
		return;
	}
	int mid = (l+r)>>1;
	Build(i<<1,l,mid);
	Build(i<<1|1,mid+1,r);
	tree[i].sum = tree[i<<1].sum + tree[i<<1|1].sum;
}
void Update(int i,int l,int r,int x,int y)
{	
	if(tree[i].sum == r-l+1) return;
	if(l == r)
	{
		tree[i].sum = sqrt(tree[i].sum);
		return;
	}
	if(tree[i].l>y||tree[i].r<x)return;
	int mid = (l+r)>>1;
	if(x<=mid) Update(i<<1,l,mid,x,y);
	if(y>mid) Update(i<<1|1,mid+1,r,x,y);
	tree[i].sum = tree[i<<1].sum + tree[i<<1|1].sum;
}
ll Query(int i,int x,int y)
{
	if(tree[i].l>=x&&tree[i].r<=y) return tree[i].sum;
	if(tree[i].l>y||tree[i].r<x) return 0;
	ll res = 0;
	if(tree[i<<1].r>=x) res += Query(i<<1,x,y);
	if(tree[i<<1|1].l<=y) res += Query(i<<1|1,x,y);
	return res;
}
int main()
{
	while(~scanf("%d",&n))
	{
		ll ans;
		int t,x1,y1,x,y;
		for(int i=1;i<=n;++i)
			scanf("%lld",&ship[i]);
		Build(1,1,n);
		scanf("%d",&m);
		printf("Case #%d:\n",++ind);
		for(int i=1;i<=m;++i)
		{
			scanf("%d%d%d",&t,&x1,&y1);
			x = min(x1,y1);
			y = max(x1,y1);
			if(t == 0)
				Update(1,1,n,x,y);
			else
			{
				ans = Query(1,x,y);
				printf("%lld\n",ans);
			}
		}
		printf("\n");
	}
	return 0;
}
```



## 主席树/可持久化线段树

见Kuangbin模板



## RMQ问题的ST算法

求区间最大值或最小值。

### 一维

m为区间长度，n为询问次数。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=100005;
ll a[maxn],dp[maxn][21];
void st(int n)
{
    for (int i=1;i<=n;i++)
        dp[i][0]=a[i];
    for (int j=1;j<=21;j++)
        for (int i=1;i+(1<<j)-1<=n;i++)
            dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);	//改成min即求区间最小值
}
int query(int l,int r)
{
    int k=log2(r-l+1);
    return max(dp[l][k],dp[r-(1<<k)+1][k]);
}
int main()
{
    int n,m,l,r;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    st(n);
    while (m--)
    {
        scanf("%d%d",&l,&r);
        printf("%lld\n",query(l,r));
    }
    return 0;
}
```



### 二维

外部对数循环结束后，queryMax(x,y,xx,yy)返回第x行至第xx行、第y列至第yy列中元素的最大值，queryMin(x,y,xx,yy)返回第x行至第xx行、第y列至第yy列中元素的最小值。

```c++
#include <bits/stdc++.h>
#define REI register int 
using namespace std;
const int MAXN = 1010;
int a, b, n;
int Log;
int stmax[MAXN][MAXN][12];	//第三维大小视内存限制而定，一般不大于21
int stmin[MAXN][MAXN][12];	//第三维大小视内存限制而定，一般不大于21
inline int queryMax(int x, int y, int xx, int yy)
{
	int t1 = stmax[x][y][Log];
	int t2 = stmax[xx - (1 << Log) + 1][y][Log];
	int t3 = stmax[x][yy - (1 << Log) + 1][Log];
	int t4 = stmax[xx - (1 << Log) + 1][yy - (1 << Log) + 1][Log];
	return max({t1,t2,t3,t4});
}
inline int queryMin(int x, int y, int xx, int yy)
{
	int t1 = stmin[x][y][Log];
	int t2 = stmin[xx - (1 << Log) + 1][y][Log];
	int t3 = stmin[x][yy - (1 << Log) + 1][Log];
	int t4 = stmin[xx - (1 << Log) + 1][yy - (1 << Log) + 1][Log];
	return min({t1,t2,t3,t4});
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> a >> b >> n;
	int tmp;
	for (int i = 1; i <= a; i++)
		for (int j = 1; j <= b; j++)
		{
			cin >> tmp;
			stmax[i][j][0] = stmin[i][j][0] = tmp;
		}
	for (REI k = 1; k <= 6; k++) // 外部对数循环，k最大值为stmax和stmin数组第三维大小的一半（向下取整）
	{
		for (REI i = 1; i + (1 << k) - 1 <= a; i++)
		{
			for (REI j = 1; j + (1 << k) - 1 <= b; j++)
			{
				stmax[i][j][k] = max({stmax[i][j][k-1], stmax[i + (1<<k-1)][j][k-1],
										stmax[i][j + (1<<k-1)][k-1],
										stmax[i+(1<<k-1)][j+(1<<k-1)][k-1]});
				stmin[i][j][k] = min({stmin[i][j][k-1], stmin[i + (1<<k-1)][j][k-1],
										stmin[i][j + (1<<k-1)][k-1],
										stmin[i+(1<<k-1)][j+(1<<k-1)][k-1]});
			}
		}
	}
	Log = (int)(log2(n));
	// cout << "LOG:" << Log << endl;
	int ans = 0x3f3f3f3f;
	for (REI i = 1; i + n - 1 <= a; i++)
	{
		for (REI j = 1; j + n - 1 <= b; j++)
		{
			ans = min(ans, queryMax(i,j,i+n-1,j+n-1) - queryMin(i,j,i+n-1,j+n-1));
			// cout << ans << endl;
		}
	}
	cout << ans << endl;
	return 0;
}
```



## K-D树

常用于多维空间信息搜索。例如，在K维空间内，存在若干点，查找某点的最近/最远的k个点；查询矩阵和等。

### 前k距离最近的点/k近邻(kNN)

n为点的数量，k为维数，给定n个点，进行Q次查询。每次查询，给定点o，查找其前m近邻，按从近到远顺序输出。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 50010;
const int DIM = 10;
inline double sqr(double x){return x*x;}
namespace KDTree {
    int K;//维数
    struct Point {
        int x[DIM];
        double distance(const Point &b) const {
            double ret = 0;
            for (int i = 0; i < K; i++)
                ret += sqr(x[i] - b.x[i]);
            return ret;
        }
        void input() {
            for (int i = 0; i < K; i++)
                scanf("%d", &x[i]);
        }
        void output() {
            for (int i = 0; i < K; i++)
                printf("%d%c", x[i], i < K - 1 ? ' ' : '\n');
        }
    };
    struct qnode {
        Point p;
        double dis;
        qnode() {}
        qnode(Point _p, double _dis) {
            p = _p;
            dis = _dis;
        }
        bool operator<(const qnode &b) const {
            return dis < b.dis;
        }
    };
    priority_queue<qnode> q;
    struct cmpx {
        int div;
        cmpx(const int &_div) { div = _div; }
        bool operator()(const Point &a, const Point &b) {
            for (int i = 0; i < K; i++)
                if (a.x[(div + i) % K] != b.x[(div + i) % K])
                    return a.x[(div + i) % K] < b.x[(div + i) % K];
            return true;
        }
    };
    bool cmp(const Point &a, const Point &b, int div) {
        cmpx cp = cmpx(div);
        return cp(a, b);
    }
    struct Node {
        Point e;
        Node *lc, *rc;
        int div;
    } pool[MAXN], *tail, *root;
    void init() {
        tail = pool;
    }
    Node *build(Point *a, int l, int r, int div) {
        if (l >= r)return NULL;
        Node *p = tail++;
        p->div = div;
        int mid = (l + r) / 2;
        nth_element(a + l, a + mid, a + r, cmpx(div));
        p->e = a[mid];
        p->lc = build(a, l, mid, (div + 1) % K);
        p->rc = build(a, mid + 1, r, (div + 1) % K);
        return p;
    }
    void search(Point p, Node *x, int div, int m) {
        if (!x)return;
        if (cmp(p, x->e, div)) {
            search(p, x->lc, (div + 1) % K, m);
            if (q.size() < m) {
                q.push(qnode(x->e, p.distance(x->e)));
                search(p, x->rc, (div + 1) % K, m);
            } else {
                if (p.distance(x->e) < q.top().dis) {
                    q.pop();
                    q.push(qnode(x->e, p.distance(x->e)));
                }
                if (sqr(x->e.x[div] - p.x[div]) < q.top().dis)
                    search(p, x->rc, (div + 1) % K, m);
            }
        } else {
            search(p, x->rc, (div + 1) % K, m);
            if (q.size() < m) {
                q.push(qnode(x->e, p.distance(x->e)));
                search(p, x->lc, (div + 1) % K, m);
            } else {
                if (p.distance(x->e) < q.top().dis) {
                    q.pop();
                    q.push(qnode(x->e, p.distance(x->e)));
                }
                if (sqr(x->e.x[div] - p.x[div]) < q.top().dis)
                    search(p, x->lc, (div + 1) % K, m);
            }
        }
    }
    void search(Point p, int m) {
        while (!q.empty())
            q.pop();
        search(p, root, 0, m);
    }
};
KDTree::Point p[MAXN];
int main()
{
    int n,k;
    while(scanf("%d%d",&n,&k) == 2){
        KDTree::K = k;
        for(int i = 0;i < n;i++)
            p[i].input();
        KDTree::init();
        KDTree::root = KDTree::build(p,0,n,0);
        int Q;
        scanf("%d",&Q);
        KDTree::Point o;
        while(Q--){
            o.input();
            int m;
            scanf("%d",&m);
            KDTree::search(o,m);
            printf("the closest %d points are:\n",m);
            int cnt = 0;
            while(!KDTree::q.empty()){
                p[cnt++] = KDTree::q.top().p;
                KDTree::q.pop();
            }
            for(int i = 0;i < m;i++)p[m-1-i].output();
        }
    }
    return 0;
}
```



### 前k距离最远的点

给定n个二维平面上的点，找出欧几里得距离下第k远的无序点对之间的距离。

```c++
#include <algorithm>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int maxn = 100010;
long long n, k;
priority_queue<long long, vector<long long>, greater<long long> > q;
struct node {
  long long x, y;
} s[maxn];
bool cmp1(node a, node b) { return a.x < b.x; }
bool cmp2(node a, node b) { return a.y < b.y; }
long long lc[maxn], rc[maxn], L[maxn], R[maxn], D[maxn], U[maxn];
void maintain(int x) {
  L[x] = R[x] = s[x].x;
  D[x] = U[x] = s[x].y;
  if (lc[x])
    L[x] = min(L[x], L[lc[x]]), R[x] = max(R[x], R[lc[x]]),
    D[x] = min(D[x], D[lc[x]]), U[x] = max(U[x], U[lc[x]]);
  if (rc[x])
    L[x] = min(L[x], L[rc[x]]), R[x] = max(R[x], R[rc[x]]),
    D[x] = min(D[x], D[rc[x]]), U[x] = max(U[x], U[rc[x]]);
}
int build(int l, int r) {
  if (l > r) return 0;
  int mid = (l + r) >> 1;
  double av1 = 0, av2 = 0, va1 = 0, va2 = 0;  // average variance
  for (int i = l; i <= r; i++) av1 += s[i].x, av2 += s[i].y;
  av1 /= (r - l + 1);
  av2 /= (r - l + 1);
  for (int i = l; i <= r; i++)
    va1 += (av1 - s[i].x) * (av1 - s[i].x),
        va2 += (av2 - s[i].y) * (av2 - s[i].y);
  if (va1 > va2)
    nth_element(s + l, s + mid, s + r + 1, cmp1);
  else
    nth_element(s + l, s + mid, s + r + 1, cmp2);
  lc[mid] = build(l, mid - 1);
  rc[mid] = build(mid + 1, r);
  maintain(mid);
  return mid;
}
long long sq(long long x) { return x * x; }
long long dist(int a, int b) {
  return max(sq(s[a].x - L[b]), sq(s[a].x - R[b])) +
         max(sq(s[a].y - D[b]), sq(s[a].y - U[b]));
}
void query(int l, int r, int x) {
  if (l > r) return;
  int mid = (l + r) >> 1;
  long long t = sq(s[mid].x - s[x].x) + sq(s[mid].y - s[x].y);
  if (t > q.top()) q.pop(), q.push(t);
  long long distl = dist(x, lc[mid]), distr = dist(x, rc[mid]);
  if (distl > q.top() && distr > q.top()) {
    if (distl > distr) {
      query(l, mid - 1, x);
      if (distr > q.top()) query(mid + 1, r, x);
    } else {
      query(mid + 1, r, x);
      if (distl > q.top()) query(l, mid - 1, x);
    }
  } else {
    if (distl > q.top()) query(l, mid - 1, x);
    if (distr > q.top()) query(mid + 1, r, x);
  }
}
int main() {
  cin >> n >> k;
  k *= 2;	//点对为无序的，每个点对会被算两边
  for (int i = 1; i <= k; i++) q.push(0);
  for (int i = 1; i <= n; i++) cin >> s[i].x >> s[i].y;
  build(1, n);
  for (int i = 1; i <= n; i++) query(1, n, i);
  cout << q.top() << endl;
  return 0;
}
```



## 左偏树

左偏树是一种可以快速合并的可并堆。维护一个小根堆，O(1)求最值，O(logn)删除最值，O(logn)合并两个左偏树。

用并查集维护连通块。

> 性质：
>
> 节点的键值小于或等于左右子节点的键值。这是左偏树的堆性质。
> 节点的左子节点的距离不小于右子节点的距离。
> 节点的距离等于它的右子节点距离加一。
> 若左偏树的距离为一定值，则节点数最少的左偏树是完全二叉树。
> 若一棵左偏树的距离为k，则这棵左偏树至少有(2的(k+1)次方-1)个节点。
> 一棵N个节点的左偏树距离最多为⌊log(N+1)-1⌋。

```c++
struct node
{
    int v;//点权
    int dist;//与最近空节点的距离
    int l,r;//左儿子结点号，右儿子结点号
    void init(int _v)
	{
		v = _v, dist = 1;
	}
}

//操作：合并
int merge(int x, int y)
{
    if (!x || !y) return x + y; // 如果左右子树有一个为空就返回那个非空的
    if (cmp(y, x)) swap(x, y); // 保证dist较大的在左边
    tr[x].r = merge(tr[x].r, y); // 递归，将dist较小的向左合并
    if (tr[tr[x].l].dist < tr[tr[x].r].dist) swap(tr[x].l, tr[x].r);
    // 如果合并之后不满足左偏性质就交换左右子树
    tr[x].dist = tr[tr[x].r].dist + 1;
    // 更新当前节点dist为右子树dist+1
    return x; // 返回合并之后根节点编号
}
```

例题1：**AcWing 2714. 左偏树**

题目描述
你需要维护一个小根堆的集合，初始时集合是空的。

该集合需要支持如下四种操作：

1 a，在集合中插入一个新堆，堆中只包含一个数 a 。
2 x y，将第 x  个插入的数和第 y 个插入的数所在的小根堆合并。数据保证两个数均未被删除。若两数已在同一堆中，则忽略此操作。
3 x，输出第 x  个插入的数所在小根堆的最小值。数据保证该数未被删除。
4 x，删除第 x  个插入的数所在小根堆的最小值（若最小值不唯一，则优先删除先插入的数）。数据保证该数未被删除。

```c++
#include <iostream>
using namespace std;
const int N = 200010;
struct Leftist_Tree_Node
{ // 定义左偏树节点
    int l, r; // 左右儿子
    int v, dist; // 点权、距离
    void init(int _v)
    {
        v = _v, dist = 1;
    }
}tr[N];
int n, idx; // idx时间戳，记录插入点的顺序
int p[N]; // 并查集父指针
int find(int x) // 并查集
{
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}
inline bool cmp(int x, int y) // 比较两个点点权，如果x的点权较小就返回1，否则返回0
{
    if (tr[x].v != tr[y].v) return tr[x].v < tr[y].v;
    return x < y; // 题目要求先删早加入的点
}
int merge(int x, int y) // 合并
{
    if (!x || !y) return x + y;
    if (cmp(y, x)) swap(x, y);
    tr[x].r = merge(tr[x].r, y);
    if (tr[tr[x].l].dist < tr[tr[x].r].dist) swap(tr[x].l, tr[x].r);
    tr[x].dist = tr[tr[x].r].dist + 1;
    return x;
}
int main()
{
    int op, x, y;
    scanf("%d", &n);
    tr[0].init(1e9); // 处理边界情况
    while (n -- )
    {
        scanf("%d%d", &op, &x);
        if (op == 1)
        {
            tr[ ++ idx].init(x); // 新建节点，分配编号
            p[idx] = idx; // 初始化并查集
        }
        else if (op == 2)
        {
            scanf("%d", &y);
            int r1 = find(x), r2 = find(y); // 找到两个根节点
            if (r1 != r2) // 如果不在一个连通块内
            {
                if (cmp(r2, r1)) swap(r1, r2); // 比大小，将点权小的放前面
                merge(r1, r2); // 左偏树合并
                p[r2] = r1; // 连通块合并
            }
        }
        else if (op == 3) printf("%d\n", tr[find(x)].v); // x所在连通块根节点的权值
        else
        {
            int rt = find(x);
            if (cmp(tr[rt].r, tr[rt].l)) swap(tr[rt].l, tr[rt].r); // 交换
            merge(tr[rt].l, tr[rt].r); // 合并左右子树，即删除根节点
            p[rt] = tr[rt].l, p[tr[rt].l] = tr[rt].l; // 并查集换根
        }
    }
    return 0;
}
```



例题2：**洛谷 P3377 【模板】左偏树/可并堆**

题目描述
如题，一开始有 n  个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：

1 x y：将第 x  个数和第 y  个数所在的小根堆合并（若第 x  或第 y  个数已经被删除或第 x  和第 y  个数在用一个堆内，则无视此操作）。

2 x：输出第 x  个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 x  个数已经被删除，则输出 −1  并无视删除操作）。

```c++
#include <iostream>
using namespace std;
const int N = 100010;
struct Leftist_Tree_Node
{
	int l, r;
	int v, dist;
	void init(int _v)
	{
		v = _v, dist = 1;
	}
}tr[N];
int n, m;
int p[N];
bool st[N]; // 如果已经被删除，则为 true
int find(int x)
{
	if (x != p[x]) p[x] = find(p[x]);
	return p[x];
}
inline bool cmp(int x, int y)
{
	if (tr[x].v != tr[y].v) return tr[x].v < tr[y].v;
	return x < y;
}
int merge(int x, int y)
{
	if (!x || !y) return x + y;
	if (cmp(y, x)) swap(x, y);
	tr[x].r = merge(tr[x].r, y);
	if (tr[tr[x].l].dist < tr[tr[x].r].dist) swap(tr[x].l, tr[x].r);
	tr[x].dist = tr[tr[x].r].dist + 1;
	return x;
}
int main()
{
	int op, x, y;
	tr[0].init(2e9);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i ++ )
	{
		scanf("%d", &x);
		tr[i].init(x), p[i] = i;
	}
	while (m -- )
	{
		scanf("%d%d", &op, &x);
		if (op == 1)
		{
			scanf("%d", &y);
			int r1 = find(x), r2 = find(y);
			if (st[x] || st[y] || r1 == r2) continue;
			// 注意 st 里是原数据而不是并查集根节点
			if (cmp(r2, r1)) swap(r1, r2);
			p[r2] = r1;
			merge(r1, r2);
		}
		else
		{
			int rt = find(x);
			if (st[x]) puts("-1");
			// 注意读题。当前点已经被删除输出-1.
			else
			{
				printf("%d\n", tr[rt].v);
				if (cmp(tr[rt].r, tr[rt].l)) swap(tr[rt].l, tr[rt].r);
				merge(tr[rt].l, tr[rt].r);
				st[rt] = true; // 注意读题。删除最小数，即删除根节点。
				p[rt] = tr[rt].l, p[tr[rt].l] = tr[rt].l;
			}
		}
	}
	return 0;
}
```

## 动态树

### 题目描述

给定 n个点以及每个点的权值，要你处理接下来的 m个操作。

操作有四种，操作从 0到 3编号。点从 1到 n 编号。

- `0 x y` 代表询问从 x到 y的路径上的点的权值的 xor和。若路径不存在输出 −1。

- `1 x y` 代表连接 x到 y，若 x到 y已经联通则无需连接。

- `2 x y` 代表删除边 (x,y)，不保证边 (x,y)存在。

- `3 x y` 代表将点 x上的权值变成 y。

  ### 输入格式

  第一行两个整数，分别为 n(1≤n≤150,000)和 m(1≤*m*≤300,000)，代表点数和操作数。

  接下来 n行，每行一个整数，整数在 1~1e9内，代表每个点的权值。

  然后有 m行，每行三个整数，分别代表操作类型和操作所需的量。

  ### 输出格式

  对于每一个 0号操作，你须输出一行一个整数，表示 x到 y的路径上点权的 xor和。若不存在输出 −1。

  ```c++
  #include<bits/stdc++.h>
  
  const int N=1.5e5+5,M=3e5+5;
  
  #define Nrt(p) (p==ch[fa[p]][0]||p==ch[fa[p]][1])
  int fa[N],sum[N],ch[N][2],val[N];
  bool rev[N];
  void Upd(int p){
      rev[p]^=1,std::swap(ch[p][0],ch[p][1]);
  }
  void Down(int p){
      if(rev[p]) Upd(ch[p][0]),Upd(ch[p][1]),rev[p]=0;
  }
  void DOWN(int p){
      if(Nrt(p)) DOWN(fa[p]);
      Down(p);
  }
  void Up(int p){
      sum[p]=sum[ch[p][0]]^val[p]^sum[ch[p][1]];
  }
  void Rot(int p){
      int f=fa[p],g=fa[f];
      if(Nrt(f)) ch[g][f==ch[g][1]]=p;
      bool k=(p==ch[f][1]);
      fa[p]=g,fa[f]=p,fa[ch[p][!k]]=f,ch[f][k]=ch[p][!k],ch[p][!k]=f;
      Up(f),Up(p);
  }
  void Splay(int p){
      for(DOWN(p);Nrt(p);Rot(p));
  }
  int Access(int x){
      int p=0;
      for(;x;x=fa[p=x]) Splay(x),ch[x][1]=p,Up(x);
      return p;
  }
  int Find(int p){
      // printf("Find %d\n",p),fflush(stdout);
      for(p=Access(p);ch[p][0];p=ch[p][0]);
      return p;
  }
  void Makeroot(int p){
      Upd(Access(p));
  }
  int Query(int x,int y){
      if(Find(x)!=Find(y)) return -1;
      return Makeroot(x),sum[Access(y)];
  }
  void Modify(int x,int y){
      Splay(x),val[x]=y,Up(x);
  }
  void Link(int x,int y){
      if(Find(x)==Find(y)) return ;
      // printf("Link %d, %d\n",x,y),fflush(stdout);
      Makeroot(x),Splay(x),fa[x]=y;
  }
  void Cut(int x,int y){
      Makeroot(x),Access(x),Splay(y);
      if(!ch[y][0]&&fa[y]==x) fa[y]=0;
  }
  
  int n,m;
  
  int main(){
      scanf("%d%d",&n,&m);
      for(int i=1;i<=n;++i) scanf("%d",val+i),sum[i]=val[i];
      for(int i=1;i<=m;++i){
          int op,x,y; scanf("%d%d%d",&op,&x,&y);
          if(op==0) printf("%d\n",Query(x,y));
          else if(op==1) Link(x,y);
          else if(op==2) Cut(x,y);
          else Modify(x,y);
          // printf("%d\n",i),fflush(stdout);
      }
      return 0;
  }
  ```


<div style="page-break-after: always;"></div>

## 李超线段树

**题目描述**

要求在平面直角坐标系下维护两个操作：

1. 在平面上加入一条线段。记第 i 条被插入的线段的标号为 i。
2. 给定一个数 k，询问与直线 x = k 相交的线段中，交点纵坐标最大的线段的编号。

**输入格式**

**本题输入强制在线**。

输入的第一行是一个整数 n，代表操作的个数。

接下来 n行，每行若干个用空格隔开的整数，第 i + 1 行的第一个整数为 op，代表第 i 次操作的类型。

若 op = 0，则后跟一个整数 k，代表本次操作为查询所所有与直线 x = (k + lastans - 1) mod 39989 + 1相交的线段中，交点纵坐标最大的线段编号。

若 op = 1，则后跟四个整数 x0, y0, x1, y1，记 xi' = (xi + lastans - 1) mod 39989 + 1，yi' = (yi + lastans - 1) mod 10^9 + 1。本次操作为插入一条两端点分别为 (x0', y0')，(x1',y1') 的线段。

其中 lastans为上次询问的答案，初始时，lastans = 0。

**输出格式**

对于每次查询，输出一行一个整数，代表交点纵坐标最大的线段的编号。若不存在任何一条线段与查询直线有交，则输出 0；若有多条线段与查询直线的交点纵坐标都是最大的，则输出编号最小的线段，同时 lastans 也应更新为编号最小的一条线段。

```c++
#include <iostream>
constexpr int MOD1 = 39989;
constexpr int MOD2 = 1000000000;
constexpr int MAXT = 40000;
using namespace std;
using pdi = pair<double, int>;

constexpr double eps = 1e-9;

int cmp(double x, double y) {
  if (x - y > eps) return 1;
  if (y - x > eps) return -1;
  return 0;
}

struct line {
  double k, b;
} p[100005];

int s[160005];
int cnt;

double calc(int id, int d) { return p[id].b + p[id].k * d; }

void add(int x0, int y0, int x1, int y1) {
  cnt++;
  if (x0 == x1)  // 特判直线斜率不存在的情况
    p[cnt].k = 0, p[cnt].b = max(y0, y1);
  else
    p[cnt].k = 1.0 * (y1 - y0) / (x1 - x0), p[cnt].b = y0 - p[cnt].k * x0;
}

void upd(int root, int cl, int cr, int u) {  // 对线段完全覆盖到的区间进行修改
  int &v = s[root], mid = (cl + cr) >> 1;
  int bmid = cmp(calc(u, mid), calc(v, mid));
  if (bmid == 1 || (!bmid && u < v)) swap(u, v);
  int bl = cmp(calc(u, cl), calc(v, cl)), br = cmp(calc(u, cr), calc(v, cr));
  if (bl == 1 || (!bl && u < v)) upd(root << 1, cl, mid, u);
  if (br == 1 || (!br && u < v)) upd(root << 1 | 1, mid + 1, cr, u);
}

void update(int root, int cl, int cr, int l, int r,
            int u) {  // 定位插入线段完全覆盖到的区间
  if (l <= cl && cr <= r) {
    upd(root, cl, cr, u);
    return;
  }
  int mid = (cl + cr) >> 1;
  if (l <= mid) update(root << 1, cl, mid, l, r, u);
  if (mid < r) update(root << 1 | 1, mid + 1, cr, l, r, u);
}

pdi pmax(pdi x, pdi y) {  // pair max函数
  if (cmp(x.first, y.first) == -1)
    return y;
  else if (cmp(x.first, y.first) == 1)
    return x;
  else
    return x.second < y.second ? x : y;
}

pdi query(int root, int l, int r, int d) {  // 查询
  if (r < d || d < l) return {0, 0};
  int mid = (l + r) >> 1;
  double res = calc(s[root], d);
  if (l == r) return {res, s[root]};
  return pmax({res, s[root]}, pmax(query(root << 1, l, mid, d),
                                   query(root << 1 | 1, mid + 1, r, d)));
}

int main() {
  ios::sync_with_stdio(false);
  int n, lastans = 0;
  cin >> n;
  while (n--) {
    int op;
    cin >> op;
    if (op == 1) {
      int x0, y0, x1, y1;
      cin >> x0 >> y0 >> x1 >> y1;
      x0 = (x0 + lastans - 1 + MOD1) % MOD1 + 1,
      x1 = (x1 + lastans - 1 + MOD1) % MOD1 + 1;
      y0 = (y0 + lastans - 1 + MOD2) % MOD2 + 1,
      y1 = (y1 + lastans - 1 + MOD2) % MOD2 + 1;
      if (x0 > x1) swap(x0, x1), swap(y0, y1);
      add(x0, y0, x1, y1);
      update(1, 1, MOD1, x0, x1, cnt);
    } else {
      int x;
      cin >> x;
      x = (x + lastans - 1 + MOD1) % MOD1 + 1;
      cout << (lastans = query(1, 1, MOD1, x).second) << endl;
    }
  }
  return 0;
}
```

有N条线段 y=ax+b (x∈[l,r)). 有Q次询问

- 0 l r a b`: 添加一条线段 y=ax+b(x∈[l,r))
- 1 p: 找到最小值 y 当x=p时. 如果答案不存在输出NO.

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 800005;
int w[MAXN], o;
int op[MAXN], l[MAXN], r[MAXN], k[MAXN];
long long b[MAXN];
int n, q;
struct Line {
    int k;
    long long b;
    long long operator()(int x) { return 1ll * k * x + b; }
    Line() : k(0), b(LLONG_MAX) {}
    Line(int k, long long b) : k(k), b(b) {}
};
struct LiChaoTree {
    Line t[MAXN << 2];
#define lc (i << 1)
#define rc (i << 1 | 1)
    void insert(Line v, int i = 1, int l = 1, int r = o) {
        int mid = (l + r) >> 1;
        if (t[i](w[mid]) > v(w[mid])) swap(v, t[i]);
        if (l == r) return;
        if (t[i](w[l]) > v(w[l])) insert(v, lc, l, mid);
        if (t[i](w[r]) > v(w[r])) insert(v, rc, mid + 1, r);
    }
    void add(int a, int b, Line v, int i = 1, int l = 1, int r = o) {
        if (a <= l && r <= b) return insert(v, i, l, r);
        int mid = (l + r) >> 1;
        if (a <= mid) add(a, b, v, lc, l, mid);
        if (b > mid) add(a, b, v, rc, mid + 1, r);
    }
    long long query(int x, int i = 1, int l = 1, int r = o) {
        if (l == r) return t[i](w[x]);
        int mid = (l + r) >> 1;
        if (x <= mid) return min(query(x, lc, l, mid), t[i](w[x]));
        else return min(query(x, rc, mid + 1, r), t[i](w[x]));
    }
} st;
int main() {
    scanf("%d%d", &n, &q);
    int root = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d%d%d%lld", &l[i], &r[i], &k[i], &b[i]); --r[i]; 
        w[++o] = l[i], w[++o] = r[i];
    }
    for (int i = n + 1; i <= n + q; i++) {
        scanf("%d", &op[i]);
        if (op[i] == 0) {
            scanf("%d%d%d%lld", &l[i], &r[i], &k[i], &b[i]); --r[i]; 
            w[++o] = l[i], w[++o] = r[i];
        } else {
            scanf("%d", &l[i]);
            w[++o] = l[i];
        }
    }
    sort(w + 1, w + 1 + o);
    o = unique(w + 1, w + 1 + o) - w - 1;
    for (int i = 1; i <= n + q; i++) l[i] = lower_bound(w + 1, w + 1 + o, l[i]) - w;
    for (int i = 1; i <= n + q; i++) r[i] = lower_bound(w + 1, w + 1 + o, r[i]) - w;
    for (int i = 1; i <= n + q; i++) {
        if (op[i] == 0) st.add(l[i], r[i], Line(k[i], b[i]));
        else {
            long long res = st.query(l[i]);
            if (res == LLONG_MAX) printf("NO\n");
            else printf("%lld\n", res);
        }
    }
    return 0;
}
```



# 博弈

可以打表找规律。

## 巴什博弈

共有T次询问，对于每次询问，有 n≤1e5个石子组成一堆，两个人轮流操作。每次可以取走至少一个，不超过m个石子(m≤n)。两个人都绝顶聪明，谁取完谁赢。（不能操作者输）给出n和m，问先手必胜还是必败。若先手必胜输出N，若先手必败输出P。

> 结论：若 (m+1)|n（整除）则先手必败 否则先手必胜
> 证明：
>
> 情况一： 当n≤m时，显然先手获胜
>
> 情况二： 当n=m+1时，先手最多可取走m个，无论其取走多少个，剩下的后手总能一次取完。
>
> 情况三： 若(m+1)|n，假设先手拿走了x个，那么后手一定可以拿走(m+1)-x个，这样无论怎么拿剩下的石头个数都将是(m+1)的倍数。那么最后一次取的时候石头个数必定还剩下(m+1)个，即情况二。
>
> 否则的话，先手可以取走模(m+1)余数个数的石头 此时转换为(m+1)|n的局面 送给后手，这样后手变成了先手，也就是后手必败。
>

```c++
#include <bits/stdc++.h>
using namespace std;
int n,m;
int main()
{
    int T;
    cin>>T;
    while (T--)
    {
        cin>>n>>m;
        if (n % (m + 1))
            puts("N");
        else
            puts("P");
    }
    return 0;
}
```



## 巴什博弈的组合

共有T次询问，对于每次询问，有 n 堆石子，第 i 堆石子有 a[i]个。两个人轮流操作，每次从任意一堆石子取至少1个、至多m个，谁取完谁赢。若先手必胜输出N，若先手必败输出P。

> 计算每堆石子的SG值，异或得到结果。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=15,M=10010;
int n, m;
int s[N],f[M];
int sg(int x)
{
    if (f[x] != -1) return f[x];
    unordered_set<int> S;
    for (int i = 0; i < m; i ++ )
    {
        int sum = s[i];
        if (x >= sum) S.insert(sg(x - sum));
    }
    for (int i = 0; ; i ++ )
        if (!S.count(i))
            return f[x] = i;
}
int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n >> m;
        for (int i = 0; i < m; i ++ ) s[i] = i + 1;		//s[]数组存储每次取石子可以选择的取值，本例题中为1~m
        memset(f, -1, sizeof f);
        int res = 0;
        for (int i = 0; i < n; i ++ )
        {
            int x;
            cin >> x;
            res ^= sg(x);
        }
        if (res) puts("N");
        else puts("P");
    }
    return 0;
}
```



## 尼姆博弈

共有T次询问，对于每次询问，有 n 堆石子，第 i 堆石子有a[i]个。两名玩家轮流行动，每次可以任选一堆，取走一个或任意多个。不能行动的人输。若先手必胜输出N，若先手必败输出P。

```c++
#include <bits/stdc++.h>
using namespace std;
int n,x,ans;
int main()
{
    int T;
    cin>>T;
    while (T--)
    {
        cin>>n;
        ans=0;
        for(int i = 1; i <= n; ++ i)
        {
            cin>>x;
            ans^=x;
        }
        if(ans==0) puts("P");
        else puts("N");
    }
    return 0;
}
```



<div style="page-break-after: always;"></div>

# 图论

## 最小生成树

### Kruskal算法

输入点数、边数、各边信息（两端点、边权值），输出最小生成树边权和，图不连通输出"orz"。

**注意：不可用于有向图！**

```c++
#include<bits/stdc++.h>
const int maxm=2e5+5;//边的最大数量
using namespace std;
int n,m,tot=0,k=0;//n端点总数，m边数，tot记录最终答案，k已经连接了多少边 
int fat[maxm];//记录集体老大 
struct node
{
	int from,to,dis;//结构体储存边 
}edge[maxm<<1];
bool cmp(const node &a,const node &b)//sort排序（当然你也可以快排） 
{
	return a.dis<b.dis;
}
int father(int x)//找集体老大，并查集的一部分 
{
	if(fat[x]!=x)
	return father(fat[x]);
	else return x;
}
void unionn(int x,int y)//加入团体，并查集的一部分 
{
	fat[father(y)]=father(x);
}
int kruskal()
{
	tot=0;
	for(int i=1;i<=n;i++) fat[i]=i;//自己最开始就是自己的老大 （初始化） 
	sort(edge+1,edge+1+m,cmp);//按权值排序（kruskal的体现） 
	for(int i=1;i<=m;i++)//从小到大遍历 
	{
		if(k==n-1) break;//n个点需要n-1条边连接 
		if(father(edge[i].from)!=father(edge[i].to))//假如不在一个团体 
		{
			unionn(edge[i].from,edge[i].to);//加入 
			tot+=edge[i].dis;//记录边权 
			k++;//已连接边数+1 
		}
	}
	return tot;
}
int main()
{
	scanf("%d%d",&n,&m);//输入点数，边数 
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&edge[i].from,&edge[i].to,&edge[i].dis);//输入边的信息
	}
	int ans=kruskal();
	if(k==n-1)
		printf("%d",ans);
	else
		printf("orz");		//图不连通
	return 0;
}
```



### Prim算法

输入点数、边数、各边信息（两端点、边权值），输出最小生成树边权和，图不连通输出"orz"。

**注意：不可用于存在双向边且两个方向边权不相等的有向图！**

```c++
#include<bits/stdc++.h>
#define R register int
const int maxn=5e3+5;//结点数n的取值范围 
const int maxm=2e5+5;//边数m的取值范围 
using namespace std;

int k,n,m,cnt,sum,ai,bi,ci,head[maxn],dis[maxn],vis[maxn];

struct Edge
{
    int v,w,next;
}e[maxm<<1];

void add(int u,int v,int w)
{
    e[++k].v=v;
    e[k].w=w;
    e[k].next=head[u];
    head[u]=k;
}

typedef pair <int,int> pii;
priority_queue <pii,vector<pii>,greater<pii> > q;

void prim()
{
    dis[1]=0;
    q.push(make_pair(0,1));
    while(!q.empty()&&cnt<n)
    {
        int d=q.top().first,u=q.top().second;
        q.pop();
        if(vis[u]) continue;
        cnt++;
        sum+=d;
        vis[u]=1;
        for(R i=head[u];i!=-1;i=e[i].next)
            if(e[i].w<dis[e[i].v])
                dis[e[i].v]=e[i].w,q.push(make_pair(dis[e[i].v],e[i].v));
    }
}

int main()
{
    memset(dis,127,sizeof(dis));
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for(R i=1;i<=m;i++)
    {
        scanf("%d%d%d",&ai,&bi,&ci);
        add(ai,bi,ci);
        add(bi,ai,ci);
    }
    prim();
    if (cnt==n)printf("%d",sum);
    else printf("orz");
}
```



## 拓扑排序

将入度为0的结点入队，将队列内的结点依次出队，删除该点及其出边，将新的入度为0的点入队，直到队列为空。出队顺序即为拓扑排序结果。

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100010;
int e[N], ne[N], idx;//邻接表存储图
int h[N];
int q[N], hh = 0, tt = -1;//队列保存入度为0的点，也就是能够输出的点，
int n, m;//保存图的点数和边数
int d[N];////保存各个点的入度
void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void topsort(){
    for(int i = 1; i <= n; i++){//遍历一遍顶点的入度。
        if(d[i] == 0)//如果入度为 0, 则可以入队列
            q[++tt] = i;
    }
    while(tt >= hh){//循环处理队列中点的
        int a = q[hh++];
        for(int i = h[a]; i != -1; i = ne[i]){//循环删除 a 发出的边
            int b = e[i];//a 有一条边指向b
            d[b]--;//删除边后，b的入度减1
            if(d[b] == 0)//如果b的入度减为 0,则 b 可以输出，入队列
                q[++tt] = b;
        }
    }
    if(tt == n - 1){//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序
        for(int i = 0; i < n; i++){//队列中保存了所有入度为0的点，依次输出
            cout << q[i] << " ";
        }
    }
    else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序
        cout << -1;//输出-1，代表错误
}
int main(){
    cin >> n >> m;//保存点的个数和边的个数
    memset(h, -1, sizeof h);//初始化邻接矩阵
    while (m -- ){//依次读入边
        int a, b;
        cin >> a >> b;
        d[b]++;//顶点b的入度+1
        add(a, b);//添加到邻接矩阵
    }
    topsort();//进行拓扑排序
    return 0;
}
```



## 一笔画问题/欧拉路

欧拉路：对于图G来说，如果存在一条通路包含G中所有的边，则该通路成为欧拉通路，即欧拉路。

欧拉回路：若欧拉路起点终点相同，则为欧拉回路。

搜索欧拉回路的代码见下文。

### 判断条件

对无向图G和有向图H：
图G存在欧拉路径与欧拉回路的充要条件分别是：
欧拉路径： 图中所有奇度点的数量为0或2。
欧拉回路： 图中所有点的度数都是偶数。

图H存在欧拉路径和欧拉回路的充要条件分别是：
欧拉路径： 所有点的入度等于出度 或者 存在一点出度比入度大1(起点)，一点入度比出度大1(终点)，其他点的入度均等于出度。
欧拉回路：所有点的入度等于出度。



### 使用邻接表储存(DFS)

G[]为存储图的邻接表。函数调用后st存储欧拉路上经过的结点。

**注意：重边多的情况下，使用邻接表储存会爆。**

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAX=100010;
int n,m,u,v,del[MAX];
int du[MAX][2];//记录入度和出度 
stack <int> st;
vector <int> G[MAX];
void dfs(int now)
{
	for(int i=del[now];i<G[now].size();i=del[now])
	{ 
		del[now]=i+1;
		dfs(G[now][i]);
	}
	st.push(now);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d",&u,&v),G[u].push_back(v),du[u][1]++,du[v][0]++;  //存储有向图的有向边
    for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
    int S=1,cnt[2]={0,0}; //记录
    bool flag=1; //flag=1表示,所有的节点的入度都等于出度,
    for(int i=1;i<=n;i++)
	{
        if(du[i][1]!=du[i][0])
        {
            flag=0;
            if(du[i][1]-du[i][0]==1/*出度比入度多1*/) cnt[1]++,S=i;
            else if(du[i][0]-du[i][1]==1/*入度比出度多1*/) cnt[0]++;
            else return puts("No"),0;
        }
    }
    if((!flag)&&!(cnt[0]==cnt[1]&&cnt[0]==1)) return !puts("No"),0;
	//不满足欧拉回路的判定条件，也不满足欧拉路径的判定条件，直接输出"No" 
    dfs(S);
    while(!st.empty()) printf("%d ",st.top()),st.pop();
    return 0; 
}
```



### 使用邻接矩阵储存(Fleury算法)

G为存储有向图的邻接矩阵。调用dfs(s)，其中s为起点。sta[i]表示欧拉路上第i个结点（编号从1开始）。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=2005;
int n,m;
int top,sta[N];
bool G[N][N];
void dfs(int x){
    sta[++top]=x;
    for(int i=1;i<=n;i++){
        if(G[x][i]>0){
            G[x][i]=G[i][x]=0;
            dfs(i);
            break;
        }
    }
}
void Euler(int x){
    bool brige;
    top=1;
    sta[top]=x;
    while(top>=0){
        brige=0;
        for(int i=1;i<=n;i++){
            if(G[sta[top]][i]>0){
                brige=1;
                break;
            }
        }
        if(!brige){
            printf("%d ",sta[top--]);
        }
        else {
            top--;
            dfs(sta[top+1]);
        }
    }
}
int main(){
    n=read();m=read();
    for(int i=1,x,y;i<=m;i++){
        x=read();y=read();
        G[x][y]=1;
        G[y][x]=1;
    }
    int num=0,start=1;
    for(int i=1;i<=n;i++){
        int deg=0;
        for(int j=1;j<=n;j++)
            deg+=G[i][j];
        if(deg%2){
            start=i;
            num++;
        }
    }   
    if(num==0||num==2)Euler(start);
    else {
        puts("No Euler path");
    }
    return 0;
}
```



## 欧拉回路

欧拉路：对于图G来说，如果存在一条通路包含G中所有的边，则该通路成为欧拉通路，即欧拉路。

欧拉回路：若欧拉路起点终点相同，则为欧拉回路。

搜索欧拉路的代码见上文。

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100100, M = 400100;
int h[N],e[M],ne[M],idx;
int ans[N*2],cnt;
bool used[M];
int din[N],dout[N];
int n,m,ver;
void add(int a,int b){
    e[idx] = b,ne[idx] = h[a],h[a] = idx++;
}
void dfs(int u){
    for(int &i = h[u]; ~i; ){
        if(used[i]){  //如果这条边用过了
            i = ne[i];   //删除这条边
            continue;
        }
        used[i] = true;  //标记这条边已使用
        if(ver == 1) used[i^1] = true;   //如果是无向图，那么这条边的反向边也要标记使用过了
        int t;
        if(ver == 1){
            t = i/2 + 1;
            if(i&1) t = -t;  //(0,1) (2,3) (4,5) 奇数编号是返回的边
        }else t = i+1;
        int j = e[i];
        i = ne[i];
        dfs(j);
        ans[cnt++] = t;
    }
}
int main()
{
    scanf("%d%d%d",&ver,&n,&m);
    memset(h,-1,sizeof h);
    for(int i = 0; i<m; i++){
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
        if(ver == 1) add(b,a);  //无向边
        din[b]++, dout[a]++;   
    }
    if(ver == 1){
        for(int i = 1; i<=n; i++){
            if(din[i]+dout[i] &1){
                //无向图含欧拉回路的充要条件是每个点的度都为偶数
                puts("NO");
                return 0;
            }
        }
    }else{
        for(int i = 1; i<=n; i++){
            if(din[i] != dout[i]){
                //有向图含欧拉回路的充要条件是每个点的入度等于出度
                puts("NO");
                return 0;
            }
        }
    }
    for(int i = 1; i<=n; i++){
        if(~h[i]) {
            dfs(i);
            break;
        }
    }
    if(cnt < m){
        puts("NO");
        return 0;
    }
    puts("YES");
    for(int i = cnt-1; i>=0; --i){
        cout<<ans[i]<<" ";
    }
    return 0;
}
```



## 割点与割边-Tarjan算法

### 割点

```c++
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 1005; // 假设最大节点数为1000
vector<int> adj[MAXN]; // 邻接表存储图
int dfn[MAXN], low[MAXN], index; // 时间戳和最低时间戳
bool isArticulation[MAXN]; // 标记是否为割点
void dfs(int u, int parent) {
    dfn[u] = low[u] = ++index;
    int children = 0; // 统计子节点数量
    for (int v : adj[u]) {
        if (!dfn[v]) { // 如果v未被访问过
            children++;
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if (parent != -1 && low[v] >= dfn[u]) {
                isArticulation[u] = true; // u是割点
            }
        } else if (v != parent) { // 如果v已被访问过且不是u的父节点
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (parent == -1 && children > 1) { // 根节点且有多于一个子节点时也是割点
        isArticulation[u] = true;
    }
}
void findArticulationPoints(int root, int n) {
    index = 0;
    fill(dfn, dfn + n, 0);
    fill(low, low + n, 0);
    fill(isArticulation, isArticulation + n, false);
    dfs(root, -1); // 从根节点开始DFS
}
int main() {
    // 构建图
    int n, m; // n为节点数，m为边数
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // 无向图，需要添加双向边
    }
 
    // 查找割点
    findArticulationPoints(1, n); // 假设根节点为1
    cout << "Articulation points: ";
    for (int i = 1; i <= n; ++i) {
        if (isArticulation[i]) {
            cout << i << " ";
        }
    }
    cout << endl;
    return 0;
}
```



### 割边

```c++
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 1005;
vector<pair<int, int>> adj[MAXN]; // 邻接表存储图，记录边的信息
int dfn[MAXN], index; // 时间戳
bool isBridge[MAXN << 1]; // 标记是否为割边，数组大小为边的两倍，因为每条边需要两个位置的标记
void dfs(int u, int parentEdge) {
    dfn[u] = ++index;
    for (const auto& edge : adj[u]) {
        int v = edge.first, id = edge.second;
        int edgeToParent = (v == parentEdge / 2 + 1) ? parentEdge : -1; // 判断是否是回溯到父节点的边
        if (!dfn[v]) {
            dfs(v, edgeToParent);
            if (dfn[u] < dfn[v]) { // (u, v) 是割边
                isBridge[id] = isBridge[id ^ 1] = true;
            }
        }
    }
}
void findBridges() {
    index = 0;
    fill(dfn, dfn + MAXN, 0);
    fill(isBridge, isBridge + MAXN * 2, false);
    dfs(1, -1); // 从节点1开始DFS，-1表示没有父边
}
int main() {
    // 构建图的示例（与前面割点判定使用相同的图）
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back({v, i * 2}); // 记录边的信息，每条边在数组中有两个位置
        adj[v].push_back({u, i * 2 + 1});
    }
 
    findBridges(); 
    cout << "Bridges: ";
    for (int u = 1; u <= n; ++u) {
        for (int i = 0; i < m * 2; i += 2) {
            if (isBridge[i] || isBridge[i + 1]) { // 判断是否为割边
            cout << "(" << adj[adj[i / 2].first][i / 2].first << ", "
                 << adj[adj[i / 2].first][i / 2].second << ") ";
        }
        }
    }
    cout << endl;
    return 0;
}
```



## 连通块

给定一个无向图，求其连通子图，即连通块。cnt为连通块数量。

```c++
#include <iostream>
#include <vector>
using namespace std;
vector<int> G[110];
bool vis[110];
void dfs(int u) {
    vis[u] = true;
    cout<<u<<" ";
    for (int i = 0; i < G[u].size(); i++) {
        int v = G[u][i];
        if (!vis[v]) {
            dfs(v);
        }
    }
}
int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        if(!vis[i]){
            cnt++;
            dfs(i);
            cout<<endl;
        }
    }
    cout << cnt << endl;
    return 0;
}
```



## 强连通分量-Tarjan算法

### 常见应用

给出的是非连通图，如：

a.有一些点，一些有向边，求至少加多少边使任意两个点可相互到达

大致方法：求出所有的分量，缩点，分别求出出度入度为0的点的数量，取多的为答案；

b.有一些点，一些有向边，求在这个图上走一条路最多可以经过多少个点

大致方法：求出所有的分量，缩点，形成一个或多个DAG图，然后做DAG上的dp

c.有一些点，一些有向边，给出一些特殊点，求终点是特殊点的最长的一条路

大致方法：求出所有分量，并标记哪些分量有特殊点，然后也是DAG的dp

> 总结：
>
> 1.遇到非连通图几乎可以肯定是要求连通分量，不论是无向还是有向图；（可以节约大量思考时间）
>
> 2.凡是对边、点的操作，在同一个分量内任意一个点效果相同的，几乎都是缩点解决问题；再粗暴点，几乎求了连通分量都要缩点；
>
> 3.一定要考虑特殊情况，如整个图是一个连通分量等（考虑到了就有10-20分）；
>
> 4.对于双连通分量要分析是边还是点双连通分量；
>
> 5.拿到题目要先搞清楚给的是连通图还是非连通图。



### 求强连通分量/缩点

求有向图各强连通分量包含的点，一个强连通分量可以缩成一个点。输出SCG i:...表示第i个强连通分量包含的结点。

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,cntb;
vector<int> edge[101];
vector<int> belong[101];
bool instack[101];
int dfn[101],low[101];
stack<int> s;
void Tarjan(int u){
	++cnt;
	dfn[u]=low[u]=cnt;
	s.push(u);
	instack[u]=true;
	for(int i=0;i<edge[u].size();i++){
		int v=edge[u][i];
		if(!dfn[v]){
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(instack[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		++cntb;
		int node;
		do{
			node=s.top();
			s.pop();
			instack[node]=false;
			belong[cntb].push_back(node);
		}while(node!=u);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		edge[u].push_back(v);
	}
	Tarjan(1);
	/*printf("id :");
	for(int i=1;i<=n;i++){
		printf("%d ",i);
	}
	printf("\n");
	printf("dfn :");
	for(int i=1;i<=n;i++){
		printf("%d ",dfn[i]);
	}
	printf("\n");
	printf("low :");
	for(int i=1;i<=n;i++){
		printf("%d ",low[i]);
	}
	printf("\n");*/
	for(int i=1;i<=cntb;i++){
		printf("SCG %d :",i);
		for(int j=0;j<belong[i].size();j++){
			printf("%d ",belong[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```



### 2-SAT问题

有n个布尔变量x1~xn，有m个条件，每个条件形式为“xi为0/1或xj为0/1”，例如“x1为1或x3为0”，给所有变量赋值使所有条件得到满足。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=4e6+5;
int n,m,a,b,x,y,tim,top,edge_sum,scc_sum;
int dfn[N],low[N],st[N],vis[N],scc[N],head[N];
//scc[i]表示结点i所在的强连通分量编号，i和i+n分别表示变量i的两种取值
struct node
{
    int to,next;
}A[N];
void add(int from,int to)
{
    edge_sum++;
    A[edge_sum].next=head[from];
    A[edge_sum].to=to;
    head[from]=edge_sum;
}
void tarjan(int u)
{
    dfn[u]=low[u]=++tim;
    st[++top]=u;
    vis[u]=1;
    for(int i=head[u];i;i=A[i].next)
    {
        int v=A[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(vis[v]) low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        scc_sum++;
        while(st[top]!=u)
        {
            scc[st[top]]=scc_sum;
            vis[st[top]]=0;
            top--;
        }
        scc[st[top]]=scc_sum;
        vis[st[top]]=0;
        top--;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&x);  //第a个数为x或第b个数为y
        scanf("%d%d",&b,&y);
        if(x==0&&y==0)      //"如果第a个数为0或第b个数为0"至少满足其一
        {
            add(a+n,b);     //a=1则b=0
            add(b+n,a);     //b=1则a=0
        }
        if(x==0&&y==1)      //"如果第a个数为0或第b个数为1"至少满足其一
        {
            add(a+n,b+n);   //a=1则b=1
            add(b,a);       //b=0则a=0
        }
        if(x==1&&y==0)      //"如果第a个数为1或第b个数为0"至少满足其一
        {
            add(a,b);       //a=0则b=0
            add(b+n,a+n);   //b=1则a=1
        }
        if(x==1&&y==1)      //"如果第a个数为1或第b个数为1"至少满足其一
        {
            add(a,b+n);     //a=0则b=1
            add(b,a+n);     //b=0则a=1
        }
    }
    for(int i=1;i<=2*n;i++) //对每个变量的每种取值进行tarjan
    {
        if(!dfn[i]) tarjan(i);
    }
    for(int i=1;i<=n;i++)   //判断无解的情况
    {
        if(scc[i]==scc[i+n]) //同一变量的两种取值在同一强联通分量里,说明无解
        {
            printf("IMPOSSIBLE\n");
            return 0;
        }
    }
    printf("POSSIBLE\n");   //否则就是有解
    for(int i=1;i<=n;i++)
    {
        if(scc[i]>scc[i+n]) printf("1 ");  //强联通分量编号越小 -> 拓扑序越大 -> 越优
        else printf("0 ");
    }
    return 0;
}
```



### 最近公共祖先(LCA)

给定n条边，m次询问，查找结点a和b的最近公共祖先。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;//用pair存询问信息
const int N=2e4+10,M=N*2;
int h[N],e[M],ne[M],w[M],idx;//邻接表的那一套
int dist[N];//存节点到根节点的距离
int st[N];//记录节点分类
int p[N];//并查集数组
int res[N];//存询问答案
int n,m;//边数，询问数
vector<pii>query[N];//存询问
void add(int a,int b,int c)//邻接表加边函数
{
    e[idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx++;
}
int find(int x)//并查集实现
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void dfs(int u,int f)//记录距离
{
    for(int i=h[u];~i;i=ne[i])//~i相当于i!=-1
    {
       int j=e[i];
       if(j==f) continue;//f保存的这个节点由哪一条边来的，确保不重复计算
       dist[j]=dist[u]+w[i];
       dfs(j,u);
    }
    return ;
}
void tarjan(int u)
{
    st[u]=1;//更新状态，正在遍历的为1
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])
        {
            tarjan(j);
            p[j]=u;//回溯完把祖先归为父节点
        }
    }
    for(auto t:query[u])//遍历与u相关的询问
    {
        int a=t.first;
        int b=t.second;
        if(st[a]==2)
        {
            int q=find(a);
            res[b]=dist[u]+dist[a]-2*dist[q];
        }
    }
    st[u]=2;//更新状态为遍历完的2
}
int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof(h));
    for(int i=0;i<n-1;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
        add(b,a,c);//无向边加两次
    }
    for(int i=0;i<m;i++)
    {
        int a,b;
        cin>>a>>b;
        query[a].push_back({b,i});//first存和他相关的边，second存询问的编号
        query[b].push_back({a,i});//因为询问的时候不知道哪一个节点先遍历完（只有先遍历完，也就是st=2后才可以计算距离），所以询问也加两次。
    }
    for(int i=1;i<=n;i++) p[i]=i;
    dfs(1,-1);//根节点没有父节点所以置为-1
    tarjan(1);
    for(int i=0;i<m;i++)
    {
        cout<<res[i]<<endl;//输出答案；
    }
    return 0;
}
```



## 双连通分量(BCC)

### 常见应用

1.给出的图是非连通图，如：

a.有一些点，一些边，加最少的边，要使得整个图变成双联通图。

大致方法：求出所有分量，把每个分量看成一个点，统计每个点的度，有一个度为一则cnt加1，答案为（cnt+1）/2；

b.有一些点，一些边，问最少多少个点单着。

大致方法：求出所有的分量即可，但要注意不同的题可能有特殊要求（如圆桌骑士要求奇圈，要用到二分图判定）

c.各种变式问题

2.给出的图是连通图，如：

a.给定一个起点一个终点，求各种问题是否能实现。

大致方法：求出所有分量，并把每个分量当成点，于是问题得到化简；

b.给一个图，然后有大量的离线回答。

大致方法：求出所有分量，再求出上下子树的信息；

c.各种变式问题；

> 总结：
>
> 1.遇到非连通图几乎可以肯定是要求连通分量，不论是无向还是有向图；（可以节约大量思考时间）
>
> 2.凡是对边、点的操作，在同一个分量内任意一个点效果相同的，几乎都是缩点解决问题；再粗暴点，几乎求了连通分量都要缩点；
>
> 3.一定要考虑特殊情况，如整个图是一个连通分量等（考虑到了就有10-20分）；
>
> 4.对于双连通分量要分析是边还是点双连通分量；
>
> 5.拿到题目要先搞清楚给的是连通图还是非连通图。



### 点双连通分量-Tarjan算法

若一个无向图中的去掉任意一个节点都不会改变此图的连通性，即不存在割点，则称作点双连通图。

在一个无向图中，若任意两点间至少存在两条“点不重复”的路径，则说这个图是点双连通的（简称双连通,biconnected）。

在一个无向图中，点双连通的极大子图称为点双连通分量V-BCC（简称双连通分量,Biconnected Component,BCC）。

> 性质：
>
> 若两个V-BCC中有公共点，则该点为原图的割点。
>
> 无向连通图中割点一定属于至少两个V-BCC，非割点只属于一个V-BCC。

```c++
#include<cstdio>
#include<cctype>
#include<vector>
using namespace std;
struct edge
{
    int to,pre;
}edges[1000001];
int head[1000001],dfn[1000001],dfs_clock,tot;
int num;//BCC数量 
int stack[1000001],top;//栈 
vector<int>bcc[1000001];
int tarjan(int u,int fa)
{
    int lowu=dfn[u]=++dfs_clock;
    for(int i=head[u];i;i=edges[i].pre)
        if(!dfn[edges[i].to])
        {
            stack[++top]=edges[i].to;//搜索到的点入栈 
            int lowv=tarjan(edges[i].to,u);
            lowu=min(lowu,lowv);
            if(lowv>=dfn[u])//是割点或根 
            {
                num++;
                while(stack[top]!=edges[i].to)//将点出栈直到目标点 
                    bcc[num].push_back(stack[top--]);
                bcc[num].push_back(stack[top--]);//目标点出栈 
                bcc[num].push_back(u);//不要忘了将当前点存入bcc 
            }
        }
        else if(edges[i].to!=fa)
            lowu=min(lowu,dfn[edges[i].to]);
    return lowu;
}
void add(int x,int y)//邻接表存边 
{
    edges[++tot].to=y;
    edges[tot].pre=head[x];
    head[x]=tot;
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y),add(y,x);
    }
    for(int i=1;i<=n;i++)//遍历n个点tarjan 
        if(!dfn[i])
        {
            stack[top=1]=i;
            tarjan(i,i);
        }
    for(int i=1;i<=num;i++)
    {
        printf("BCC#%d: ",i);
        for(int j=0;j<bcc[i].size();j++)
            printf("%d ",bcc[i][j]);
        printf("\n");
    }
    return 0;
}
```



### 边双连通分量-Tarjan算法

若一个无向图中的去掉任意一条边都不会改变此图的连通性，即不存在割边，则称作边双连通图。

> 性质：
>
> 一个E-BCC中没有割边。

```c++
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int maxn = 500010, maxm = 4000010;
int n, m, cnt = 1, ans, id;
int dfn[maxn], low[maxn], head[maxn], dcc[maxn];
struct edge
{
	int to, nxt;
}e[maxm];
bool b[maxm];
vector <vector <int> > Ans;
void add(int f, int t)
{
	e[++cnt].to = t;
	e[cnt].nxt = head[f];
	head[f] = cnt;
}
void tarjan(int node, int in_edge)
{
	dfn[node] = low[node] = ++id;
	for (int i = head[node]; i; i = e[i].nxt)
	{
		const int to = e[i].to;
		if (dfn[to] == 0)
		{
			tarjan(to, i);
			if (dfn[node] < low[to])
				b[i] = b[i ^ 1] = 1;
			low[node] = min(low[node], low[to]);
		}
		else if (i != (in_edge ^ 1))
			low[node] = min(low[node], dfn[to]);
	}
}
void dfs(int node, int ndcc)
{
	dcc[node] = ndcc;
	Ans[ndcc - 1].push_back(node);
	for (int i = head[node]; i; i = e[i].nxt)
	{
		int to = e[i].to;
		if (dcc[to] || b[i]) continue;
		dfs(to, ndcc);
	}
}
int main()
{
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; ++i)
	{
		int f, t;
		scanf("%d %d", &f, &t);
		if (f == t) continue;
		add(f, t);
		add(t, f);
	}
	for (int i = 1; i <= n; ++i)
		if (dfn[i] == 0)
			tarjan(i, 0);
	for (int i = 1; i <= n; ++i)
		if (dcc[i] == 0)
		{
			Ans.push_back(vector <int>());
			dfs(i, ++ans);
		}
	printf("%d\n", ans);
	for (int i = 0; i < ans; ++i)
	{
		printf("%d", Ans[i].size());
		for (int j = 0; j < Ans[i].size(); ++j)
			printf(" %d", Ans[i][j]);
		printf("\n");
	}
	return 0;
}
```



## 负环-SPFA算法

负环：该环上的边权和为负数。当图存在负环时，最短路无解。

当BFS路径经过的点数大于总结点数时，说明图存在负环。若一张图连通，那么肯定可以经过<=n-1条边从一点到任意一点的。不存在负环时，一条路径最多经过n-1条边；存在负环时，spfa会一直绕着负环走，经过边数一定超过n-1，所以只用判断最短路经过的边数。

此程序判断图（不限有向图或无向图）是否存在负环。

```c++
#include<iostream>
using namespace std;
#include<algorithm>
#include<cstring>
#include<queue>
const int N=1e5+10;
int h[N],e[N],ne[N],w[N],idx;
int dist[N],cns[N],n,m;//cns[i]表示当前dist[i]表示的最短路径的边数
//int Q[N],front,rear;
bool st[N];
void add(int a,int b,int c){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx;
    w[idx++]=c;
}
bool spfa(){
    queue<int> Q;
    for(int i=1;i<=n;i++){//只从1开始松弛有可能到不了负环，所以每个点各自出发
        st[i]=true;
        Q.push(i);
    }
    int t,j;
    while(!Q.empty()){
        t=Q.front();
        Q.pop();
        st[t]=false;
        for(int i=h[t];i!=-1;i=ne[i]){
            j=e[i];
            if(dist[j]>dist[t]+w[i]){
                dist[j]=dist[t]+w[i];
                cns[j]=cns[t]+1;//1-j最短路径由1-t和t-j构成
                if(cns[j]>n-1) return true;//正常情况下1-n经过的边数最多为n-1
                if(!st[j]){
                    Q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
int main(void){
    memset(h,-1,sizeof(h));
    cin>>n>>m;
    int a,b,c;
    for(int i=0;i<m;i++){
        cin>>a>>b>>c;
        add(a,b,c);		//有向边
    }
    if(spfa()) cout<<"Yes";
    else cout<<"No";
}
```



## 最短路径

### 单源最短路径(Dijkstra算法)

n为点数，m为边数，s为起点。dis[i]为从s出发到点i的最短路径长度。

Dijkstra算法也可用于求解次短路。

**注意：无法处理负边和负环。**

```c++
#include<bits/stdc++.h>
const int MaxN = 100010, MaxM = 500010,INF=0x7fffffff;
struct edge
{
    int to, dis, next;
};
edge e[MaxM];
int head[MaxN], dis[MaxN], cnt;
bool vis[MaxN];
int n, m, s;
inline void add_edge( int u, int v, int d )
{
    cnt++;
    e[cnt].dis = d;
    e[cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
struct node
{
    int dis;
    int pos;
    bool operator <( const node &x )const
    {
        return x.dis < dis;
    }
};
std::priority_queue<node> q;
inline void dijkstra()
{
    dis[s] = 0;
    q.push( ( node ){0, s} );
    while( !q.empty() )
    {
        node tmp = q.top();
        q.pop();
        int x = tmp.pos, d = tmp.dis;
        if( vis[x] )
            continue;
        vis[x] = 1;
        for( int i = head[x]; i; i = e[i].next )
        {
            int y = e[i].to;
            if( dis[y] > dis[x] + e[i].dis )
            {
                dis[y] = dis[x] + e[i].dis;
                if( !vis[y] )
                {
                    q.push( ( node ){dis[y], y} );
                }
            }
        }
    }
}
int main()
{
    scanf( "%d%d%d", &n, &m, &s );
    for(int i = 1; i <= n; ++i)
        dis[i] = INF;
    for( int i = 0; i < m; ++i )
    {
        int u, v, d;
        scanf( "%d%d%d", &u, &v, &d );
        add_edge( u, v, d );
    }
    dijkstra();
    for( int i = 1; i <= n; i++ )
        printf( "%d ", dis[i] );
    return 0;
}
```



### 单源最短路径(SPFA算法)

时间复杂度高于Dijkstra算法，非必要不使用SPFA。

**注意：可处理负边，可判断是否存在负环，但无法计算存在负边情况的最短路径。**

使用SPFA判断负环的代码见上文。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e5+10;
const int MAXM=2*MAXN;
bool vis[MAXN];
int dis[MAXN],cnt,head[MAXM];
int s;  //起点
struct edge{
    int to , w , nxt;
}a[MAXM];
void add(int u , int v , int w) {
    a[++ cnt].w = w;
    a[cnt].to = v;
    a[cnt].nxt = head[u];
    head[u] = cnt;
}
struct node {
    int id , w;
    node(int iid , int ww) {
        id = iid;
        w = ww;
    }
};
queue<node> q;
int SPFA() {
    memset(dis , 0x3f, sizeof(dis));
    dis[s] = 0;
    q.push(node(s , 0));
    while(!q.empty()) {
        int u = q.front().id;
        q.pop();
        vis[u] = 0;
        for (int i = head[u] ; i ; i = a[i].nxt) {
            int v = a[i].to , w = a[i].w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    vis[v] = 1;
                    q.push(node(v , dis[v]));
                }
            }
        }
    }
    return 1;
}
int main()
{
    int n,m,u,v,w;
    cin>>n>>m>>s;
    cnt=0;
    for (int i=0;i<m;i++)
    {
        cin>>u>>v>>w;
        add(u,v,w);
    }
    SPFA();
    for (int i=1;i<=n;i++)
        cout<<dis[i]<<" ";
    return 0;
}
```



### 多源最短路径(Floyd算法)

在主函数中，Init()函数、floyd()函数、print()函数依次调用。n为点数，m为边数。`dp[i][j]`表示顶点i到j最短路径长度，`pre[i][j]`表示从i到j的最短路径上j前面一个顶点的编号。

**注意：无法处理负边和负环。**

```c++
const int INF=0x3f3f3f3f;
void floyd() {
	for (int k = 1 ; k <= n ; k ++) {
		for (int i = 1 ; i <= n ; i ++) {
			for (int j = 1 ; j <= n ; j ++) {
				if (dp[i][k] + dp[k][j] < dp[i][j]) {
					dp[i][j] = dp[i][k] + dp[k][j];
					pre[i][j] = pre[k][j];
				}
			}
		}
	} 
}
void print(int x) {
	if (pre[s][x] == 0) return;
	print(pre[s][x]);
	printf(" %d", x);
}
void Init()
{
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            if (i==j)
            {
                dp[i][j]=0;
                pre[i][j]=i;
            }
    		else
            {
                dp[i][j]=INF;
                pre[i][j]=0;
            }
        }
    }
    for (int i=0;i<m;i++)
    {
        cin>>u>>v>>w;
        dp[u][v]=w;
        pre[u][v]=u;
    }
}
```



## 次短路径

### 单源次短路径(Dijkstra算法)

调用dijkstra()函数后，`dist[i][0]`表示到结点i的最短路径长度，`dist[i][1]`表示到结点i的次短路径长度。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010,M = 10010;
int h[N],e[M],ne[M],w[M],idx;
//状态0表示的是求最下，状态1表示求的是次小
int cnt[N][2];  //cnt[i][0]表示当前到达节点是i，且求的是0状态下的所有路径中最短路径的边数
int dist[N][2]; //dist[i][0]表示当前到达节点是i，且求的是0状态下的最短路径的值
bool st[N][2];  //与上面同理
int n,m,S,T;  //S表示起点，T表示终点
struct node{   //小根堆，重载大于号
    int id,type,distance;   //分别是编号，状态，和当前点到起点的最小或次小距离
    bool operator> (const node& a) const{  //从大到小排序
        return distance > a.distance;
    }
};
void add(int a,int b,int c){
    w[idx] = c;
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
int dijkstra(){
    memset(st, 0, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    priority_queue<node,vector<node>,greater<node>> heap;
    dist[S][0] = 0;
    cnt[S][0] = 1;
    heap.push({S,0,0});
    while(heap.size()){
        node t = heap.top();
        heap.pop();
        int ver = t.id , type = t.type , distance = t.distance; 
        if(st[ver][type]) continue;
        st[ver][type] = true;
        for(int i = h[ver];i != -1;i = ne[i]){
            int j = e[i];
            //先考虑最短的情况(大于、等于)
            if(dist[j][0] > dist[ver][type] + w[i]){
                //dist[j][0]成为次小,先要赋值给dist[j][]中次小的状态
                dist[j][1] = dist[j][0]; cnt[j][1] = cnt[j][0];
                heap.push({j, 1, dist[j][1]});  //发生改变就要入队
                dist[j][0] = dist[ver][type] + w[i];  cnt[j][0] = cnt[ver][type];  //直接转移
                heap.push({j,0,dist[j][0]});
            }else if(dist[j][0] == dist[ver][type] + w[i]){  
                cnt[j][0] += cnt[ver][type]; //从t经过的最短路，在j上经过的时候也是最短路
            //轮到枚举次小
            }else if(dist[j][1] > dist[ver][type] + w[i]){
                dist[j][1] = dist[ver][type] + w[i];
                cnt[j][1] = cnt[ver][type];
                 heap.push({j, 1, dist[j][1]});
            }else if(dist[j][1] == dist[ver][type] + w[i]){
                cnt[j][1] += cnt[ver][type];  //从t经过的最短路，在j上经过的时候也是最短路
            } 
        }
    }
    int res = cnt[T][0];
    //最后还要特判以下最小和次小的路径之间是否相差1符合要求
    if (dist[T][0] + 1 == dist[T][1]) res += cnt[T][1];  
    return res;
}
int main(){
    int t;
    cin >> t;
    while(t--){
        memset(h,-1,sizeof h);
        cin >> n >> m;
        for(int i = 0;i < m;++i){
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            add(a,b,c);
        }
        scanf("%d%d",&S,&T);
        cout << dijkstra() << endl;
    }
    return 0;
}
```



## 二分图

### 二分图的判定

定义：有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接。

即图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。例如下图

<img src="https://algorithm-template-1328964093.cos.ap-nanjing.myqcloud.com/7%5B(3V)AWJ36~@64_75H~I%5DF_tmb.png" alt="img" style="zoom: 25%;" />

判定方式：

这个图是二分图当且仅当图内没有奇数环（点数为奇数的环）。

证明：
反证法：如果图内有奇数环，那么把里面任意一点归入一号集合中，他右面的就得归入二号集合中，再右边的又是一号集合，这么一直归入下去，发现最初的那一点又要归入二号集合中，这就矛盾了，所以不行。

如果图里没有奇环，那么这张图一定是二分图。
把一个点归到左边，再把所有与他相邻的点归到右边，再把所有与他们相邻的点归到左边，由于没有负环，所以肯定能弄完。
这个过程可以叫做染色：

开始对任意一未染色的顶点染色。

判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色。

若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断。

使用BFS和DFS完成：

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100010 * 2;
int e[N], ne[N], idx;//邻接表存储图
int h[N];
int color[N];//保存各个点的颜色，0 未染色，1 是红色，2 是黑色
int n, m;//点和边
void add(int a, int b)//邻接表插入点和边
{
    e[idx] = b, ne[idx]= h[a], h[a] = idx++;
}
bool dfs(int u, int c)//深度优先遍历
{
    color[u] = c;//u的点成 c 染色

    //遍历和 u 相邻的点
    for(int i = h[u]; i!= -1; i = ne[i])
    {
        int b = e[i];                   
        if(!color[b])//相邻的点没有颜色,则递归处理这个相邻点
        {
            if(!dfs(b, 3 - c)) return false;//（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）
                                            //（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）
        }
        else if(color[b] && color[b] != 3 - c)//如果已经染色，判断颜色是否为 3 - c
        {                                     
            return false;//如果不是，说明冲突，返回                   
        }
    }
    return true;
}
int main()
{
    memset(h, -1, sizeof h);//初始化邻接表
    cin >> n >> m;
    for(int i = 1; i <= m; i++)//读入边
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    for(int i = 1; i <= n; i++)//遍历点
    {
        if(!color[i])//如果没染色
        {
            if(!dfs(i, 1))//染色该点，并递归处理和它相邻的点
            {
                cout << "No" << endl;//出现矛盾，输出NO 
                return 0;
            }

        }
    }
    cout << "Yes" << endl;//全部染色完成，没有矛盾，输出YES
    return 0;
}
```



### 二分图最大匹配(匈牙利算法)

匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。

最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。

完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。

交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。

增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替 路称为增广路。

时间复杂度：对于左侧每个点，最多去尝试右侧点的个数次，所以是：o(n * m)

```c++
#include<iostream>
#include <cstring>
#include<algorithm>
using namespace std;
// 邻接表存储图
int n1, n2, m;
int h[500], e[100010],ne[100010], idx = 0;
//st 标记是否递归找过， match[x]：和 x 编号的男生的编号
int st[510], match[510];
//存图函数
void add(int a, int b){
    e[idx] = b, ne[idx] = h[a]; h[a] = idx++;
}
//递归找可以匹配的点
bool find(int x){
    // 和各个点尝试能否匹配
    for(int i = h[x]; i != -1; i = ne[i]){
        int b = e[i];
        if(!st[b]){//打标记
            st[b] = 1;
            // 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配
            if(match[b] == 0 || find(match[b])){
                // 和当前尝试点匹配在一起
                match[b] = x;
                return true;
            }
        }
    }
    return false;
}
int main(){
    memset(h, -1, sizeof h);
    cin >> n1 >> n2 >> m;
    // 保存图，因为只从一遍找另一边，所以该无向图只需要存储一个方向
    for(int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    int res = 0;
    //为各个点找匹配
    for(int i = 1; i <= n1; i++){
        memset(st, 0, sizeof st);
        //找到匹配
        if(find(i)) res++;
    }
    cout << res;
    return 0;
}
```



## 网络流

### 单源点-单汇点最大流(Dinic算法)

给定n个点和m条有向边，每条边从点u到点v，其容量为c。求以s为源点，以t为汇点的最大流。

```c++
#include<bits/stdc++.h>
#define maxn 1300
#define maxm 120010
using namespace std;
struct edge{
    int u,v,cap;
}e[maxm];
struct Dinic{
    int tp,s,t,dis[maxn],cur[maxn],que[maxn];
    vector<edge>e;vector<int>v[maxn];
    void AddEdge(int x,int y,int flw){
        e.push_back(edge{x,y,flw});
        e.push_back(edge{y,x,0});
        v[x].push_back(e.size()-2);
        //v[y].push_back(e.size()-1);
    }
    int bfs(){
        memset(dis,0x3f,sizeof dis);
        int l=1,r=1;que[1]=s;dis[s]=0;
        while(l<=r){
            int p=que[l++],to;
            for(int i:v[p])if(e[i].cap && dis[to=e[i].v]>1e9)
                    dis[to]=dis[p]+1,que[++r]=to;
        }
        return dis[t]<1e9;
    }
    int dfs(int p,int a){
        if(p==t || !a)return a;
        int sf=0,flw;
        for(int &i=cur[p],to;i<(int)v[p].size();++i){
            edge &E=e[v[p][i]];
            if(dis[to=E.v]==dis[p]+1 && (flw=dfs(to,min(a,E.cap)))){
                E.cap-=flw;e[v[p][i]^1].cap+=flw;
                a-=flw;sf+=flw;
                if(!a)break;
            }
        }
        return sf;
    }
    int dinic(int s,int t,int tp=1){
        this->s=s;this->t=t;this->tp=tp;
        int flw=0;
        while(bfs()){
            memset(cur,0,sizeof cur);
            flw+=dfs(s,INT_MAX);
        }
        return flw;
    }
}sol;
int n,m,i,s,t,ans;
int main(){
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(i=0;i<m;i++)
    {
        int t1,t2,t3;
        scanf("%d%d%d",&t1,&t2,&t3);
        if (t3!=0)
        {
            e[i].u=t1;
            e[i].v=t2;
            e[i].cap=t3;
        }
    }
    sort(e,e+m,[](edge a,edge b){return a.cap>b.cap;});
    for(int tp:{0,1})for(int p=1<<30,i=0;p;p/=2){
            while(i<m && e[i].cap>=p){
                if(tp)sol.v[e[i].v].push_back(i*2+1);
                else sol.AddEdge(e[i].u,e[i].v,e[i].cap);
                i++;
            }
            ans+=sol.dinic(s,t,tp);
        }
    printf("%d\n",ans);
    return 0;
}
```



### 多源点-多汇点最大流(Dinic算法)

> 思路：
>
> 建立虚拟源点S，分别向源点连容量是∞∞的边（正无穷的原因是不能让其成为流量的限制）。
>
> 建立虚拟汇点T，汇点分别向T连容量是∞∞的边（正无穷的原因是不能让其成为流量的限制）。
>
> 使用Dinic算法，求S到T的最大流。

<img src="https://algorithm-template-1328964093.cos.ap-nanjing.myqcloud.com/3fdfc21a74204cc888b90c7ad247eaf0.png" alt="img" style="zoom: 80%;" />

```c++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N=1e4+10,M=(2*N+1e5+10)*2,INF=1e9;
int S,T;
int h[N],ne[M],e[M],f[M],idx;
int d[N],cur[N];
void add(int a, int b, int c){
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;
}
bool bfs(){
    memset(d,-1,sizeof d);
    queue<int>q;
    q.push(S);
    cur[S]=h[S];d[S]=0;
    while(!q.empty()){
        int t=q.front();
        q.pop();
        for(int i=h[t]; ~i; i=ne[i]){
            int ver=e[i];
            if(d[ver]==-1 && f[i]){
                cur[ver]=h[ver];
                d[ver]=d[t]+1;
                if(ver==T)return true;
                q.push(ver);
            }
        }
    }
    return false;
}
int find(int u, int limit){
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u]; ~i && flow<limit; i=ne[i]){
        int ver=e[i];
        cur[u]=i;
        if(d[ver]==d[u]+1 && f[i]){
            int t=find(ver,min(f[i],limit-flow));
            if(!t)d[ver]=-1;
            f[i]-=t;f[i^1]+=t;flow+=t;
        }
    }
    return flow;
    
}
int dinic(){
    int res=0,flow=0;
    while(bfs())while(flow=find(S,INF))res+=flow;
    return res;
}
int main(){
    memset(h,-1,sizeof h);
    int n,m,s,t;
    cin>>n>>m>>s>>t;
    S=0,T=n+1;
    for(int i=0; i<s; i++){
        int tt;
        cin>>tt;
        add(S,tt,INF);
    }
    for(int i=0; i<t; i++){
        int tt;
        cin>>tt;
        add(tt,T,INF);
    }
    for(int i=0; i<m; i++){
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    cout<<dinic()<<endl;
    return 0;
}
```



### 关键边

“关键边”：增加这条边的流量，源点s到汇点t的最大流量将增加。

> 思路：
>
> 因为关键边一定是满流边（如果最开始都没用完，再增加这条边的流量肯定也用不上），所以我们跑完网络最大流后，直接判断这些满流边（即残量为0的边）是否满足：①源点s能否到达这条边的起点；②这条边的终点能否到达汇点t。满足这两点时，增加这条边的流量，最大流就肯定会增加。对于某条满流边，如果增大容量使其流量不能跑满，那么如果这条边存在于一条增广路中，那么它就是关键边。反之，因为其他边容量的限制，增大它的容量也无法继续增广，因此不是关键边。
>
> **注意：满流边不一定是关键边，因为可能会出现一条路径上有几条满流边的情况，这时候增加其中一条边的流量，这条路径上的最大流不会增加。**

对于一个有n个结点，m条边的有向图，结点编号0~(n-1)。m条边，从u到v，容量为c。以0号结点为源点，(n-1)号结点为汇点，求关键边数量。时间复杂度为O(n的2次方*m)。

```c++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N=1e4+10,M=(2*N+1e5+10)*2,INF=1e9;
int S,T;
int h[N],ne[M],e[M],f[M],idx;
int d[N],cur[N];
bool vis_s[N],vis_t[N];
void add(int a, int b, int c){
    e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;
    e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;
}
bool bfs(){
    memset(d,-1,sizeof d);
    queue<int>q;
    q.push(S);
    cur[S]=h[S];d[S]=0;
    while(!q.empty()){
        int t=q.front();
        q.pop();
        for(int i=h[t]; ~i; i=ne[i]){
            int ver=e[i];
            if(d[ver]==-1 && f[i]){
                cur[ver]=h[ver];
                d[ver]=d[t]+1;
                if(ver==T)return true;
                q.push(ver);
            }
        }
    }
    return false;
}
int find(int u, int limit){
    if(u==T)return limit;
    int flow=0;
    for(int i=cur[u]; ~i && flow<limit; i=ne[i]){
        int ver=e[i];
        cur[u]=i;
        if(d[ver]==d[u]+1 && f[i]){
            int t=find(ver,min(f[i],limit-flow));
            if(!t)d[ver]=-1;
            f[i]-=t;f[i^1]+=t;flow+=t;
        }
    }
    return flow;
}
int dinic(){
    int res=0,flow=0;
    while(bfs())while(flow=find(S,INF))res+=flow;
    return res;
}
 
void dfs(int u, bool st[], int fla){
    st[u]=true;
    for(int i=h[u]; ~i; i=ne[i]){
        int ver=e[i];
        int j=i^fla;
        if(f[j] && !st[ver]){
            dfs(ver,st,fla);
        }
    }
}
int main(){
    memset(h,-1,sizeof h);
    int n,m;
    cin>>n>>m;
    S=0,T=n-1;
    
    for(int i=0; i<m; i++){
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    dinic();
    dfs(S,vis_s,0);
    dfs(T,vis_t,1);
    int res=0;
    for(int i=0; i<2*m; i+=2){
        if(!f[i] && vis_t[e[i]] && vis_s[e[i^1]]){
            res++;
        }
    }
    cout<<res<<endl;
}
```

## 树链剖分

已知一棵包含 N*N* 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：

- `1 x y z`，表示将树从 x*x* 到 y*y* 结点最短路径上所有节点的值都加上 z*z*。

- `2 x y`，表示求树从 x*x* 到 y*y* 结点最短路径上所有节点的值之和。

- `3 x z`，表示将以 x*x* 为根节点的子树内所有节点值都加上 z*z*。

- `4 x` 表示求以 x*x* 为根节点的子树内所有节点值之和

  ```c++
  #include <bits/stdc++.h>
  using namespace std;
  #define ls p<<1
  #define rs p<<1|1
  #define mid ((l+r)>>1)
  struct node{
      int nex,to;
  };
  const int N=1e5+10;
  node edge[N<<1];
  int head[N],tot;
  void add(int from,int to){
      edge[++tot].nex=head[from];
      edge[tot].to=to;
      head[from]=tot;
  }
  int w[N],n,m,root,mod;//初始权值,n个节点，m个询问，根节点
  int dep[N],fa[N],son[N],siz[N];//第一部分DFS
  int top[N],nid[N],oid[N],nw[N],cnt;//第二部分DFS
  
  int tree[N<<2],tag[N<<2];//线段树所需
  
  void DFS1(int now,int fath){
      fa[now]=fath;
      siz[now]=1;
      son[now]=0;
      dep[now]=dep[fath]+1;
      for(int i=head[now];i;i=edge[i].nex){
          if(edge[i].to==fath)
              continue;
          DFS1(edge[i].to,now);
          siz[now]+=siz[edge[i].to];
          if(siz[son[now]]<siz[edge[i].to])
              son[now]=edge[i].to;
      }
  }
  void DFS2(int now,int topx){//topx，先重儿子再轻儿子
      top[now]=topx;
      nid[now]=++cnt;
      nw[cnt]=w[now];
      if(son[now])
          DFS2(son[now],topx);
      else
          return ;
      for(int i=head[now];i;i=edge[i].nex){
          if(edge[i].to!=fa[now]&&edge[i].to!=son[now])
              DFS2(edge[i].to,edge[i].to);
      }
  }
  int LCA(int x,int y){
      while(top[x]!=top[y]){
          if(dep[top[x]]<dep[top[y]])
              swap(x,y);
          x=fa[top[x]];
      }
      return dep[x]<dep[y]?x:y;
  }
  //线段树部分
  void up(int p){
      tree[p]=tree[ls]+tree[rs];
  }
  void down(int l,int r,int p){
      tag[ls]+=tag[p];
      tag[rs]+=tag[p];
      tree[ls]+=(mid-l+1)*tag[p];
      tree[ls]%=mod;
      tree[rs]+=(r-mid)*tag[p];
      tree[rs]%=mod;
      tag[p]=0;
  }
  void bulid(int l,int r,int p){
      if(l==r){
          tree[p]=nw[l];
          return ;
      }
      bulid(l,mid,ls);
      bulid(mid+1,r,rs);
      up(p);
  }
  void update(int l,int r,int nl,int nr,int p,int k){
      if(l>=nl&&r<=nr){
          tree[p]+=(r-l+1)*k;
          tree[p]%=mod;
          tag[p]+=k;
          return ;
      }
      down(l,r,p);
      if(mid>=nl)
          update(l,mid,nl,nr,ls,k);
      if(mid<nr)
          update(mid+1,r,nl,nr,rs,k);
      up(p);
  }
  int query(int l,int r,int nl,int nr,int p){
      if(l>=nl&&r<=nr)
          return tree[p]%mod;
      long long res=0ll;
      down(l,r,p);
      if(mid>=nl)
          res+=query(l,mid,nl,nr,ls);
      if(mid<nr)
          res+=query(mid+1,r,nl,nr,rs);
      return res;
  }
  //线段树完结
  //线段树使用部分
  int q_Range(int x,int y){
      long long ans=0ll;
      while(top[x]!=top[y]){
          if(dep[top[x]]<dep[top[y]])
              swap(x,y);
          ans=(ans+query(1,n,nid[top[x]],nid[x],1))%mod;
          x=fa[top[x]];
      }
      if(dep[x]>dep[y])
          swap(x,y);
      ans=(ans+query(1,n,nid[x],nid[y],1))%mod;
      return ans%mod;
  }
  int q_Tree(int x){
      return query(1,n,nid[x],nid[x]+siz[x]-1,1)%mod;
  }
  void upd_Range(int x,int y,int k){
      k%=mod;
      while(top[x]!=top[y])
      {
          if(dep[top[x]]<dep[top[y]])
              swap(x,y);
          update(1,n,nid[top[x]],nid[x],1,k);
          x=fa[top[x]];
      }
      if(dep[x]>dep[y])
          swap(x,y);
      update(1,n,nid[x],nid[y],1,k);
  }
  void upd_Tree(int x,int k){
      update(1,n,nid[x],nid[x]+siz[x]-1,1,k);
  }
  signed main(){
      scanf("%d%d%d%d",&n,&m,&root,&mod);
      for(int i=1;i<=n;i++)
          scanf("%d",&w[i]);
      for(int i=1,l,r;i<=n-1;i++){
          scanf("%d%d",&l,&r);
          add(l,r);
          add(r,l);
      }
      DFS1(root,0);
      DFS2(root,root);
      bulid(1,n,1);
      for(int i=1;i<=m;i++){
          int c,x,y,k;
          scanf("%d",&c);
          if(c==1){
              scanf("%d%d%d",&x,&y,&k);
              upd_Range(x,y,k);
          }
          else if(c==2){
              scanf("%d%d",&x,&y);
              printf("%d\n",q_Range(x,y)%mod);
          }
          else if(c==3){
              scanf("%d%d",&x,&k);
              upd_Tree(x,k);
          }
          else{
              scanf("%d",&x);
              printf("%d\n",q_Tree(x)%mod);
          }
      }
  	return 0;
  }
  
  
  ```

  

# 计算几何

自定义头文件如下：

```c++
#include<bits/stdc++.h>
#define eps 1e-9
const double pi=3.141592653;
using namespace std;

/////////////////////////////////////////////////////
struct Point
{
	double x,y;
//	Point(){};
	Point(double x=0,double y=0):x(x),y(y){}
}; 

typedef Point Vector;

//四则运算

//向量加法 
Vector operator +(Vector A,Vector B)
{ return Vector(A.x+B.x,A.y+B.y); } 

//向量减法,两点求向量 
Vector operator -(Point A,Point B)
{ return Vector(A.x-B.x,A.y-B.y); }

//向量数乘
Vector operator *(Vector A,double p)
{ return Vector(A.x*p,A.y*p); }

//向量数除
Vector operator /(Vector A,double p)
{ return Vector(A.x/p,A.y/p); }
 

//x第一关键字，y第二关键字排序
bool operator <(const Point &a,const Point &b)
{ return a.x<b.x||(a.x==b.x&&a.y<b.y); } 

//弧度角度转换

double R_to_D(double rad)
{ return 180/pi*rad; }	
double D_to_R(double D)
{ return pi/180*D; }


int sgn(double x)
{//判断正负函数，0为0，-1为负，1为正
	if(fabs(x)<eps)
		return 0;
	if(x>0)
		return -1;
	return 1; 
}

bool operator ==(const Point &a,const Point &b)
{ return !sgn(a.x-b.x)&&!sgn(a.y-b.y); }

//叉积、点积
double Dot(Vector A,Vector B)
{
	return A.x*B.x+A.y*B.y;
} 
double Cross(Vector A,Vector B)
{
	return A.x*B.y-B.x*A.y;
}


//判断向量bc是不是在ab的逆时针方向 
bool ToLeftTest(Point a,Point b,Point c)
{
	return Cross(b-a,c-b)>0;
}

//取模，求长度
double Length(Vector A)
{
	return sqrt(Dot(A,A));
 } 

//计算两向量夹角
double Angle(Vector A,Vector B)
{
	return acos(Dot(A,B)/Length(A)/Length(B));
 } 

//计算两向量构成的平行四边形的有向面积（逆时针为正，顺时针为负）
double Area2(Point A,Point B,Point C)
{
	return Cross(B-A,C-A);
 } 

//求向量的法向量
Vector Normal(Vector A)
{
	double L=Length(A);
	return Vector(-A.y/L,A.x/L); 
 } 
//求单位向量
Vector Format(const Vector &A)
{
	double L=Length(A);
	return Vector(A.x/L,A.y/L);
 } 

//向量逆时针旋转后的向量 
Vector Rotate(Vector A,double rad)
{
	return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));
}

//判断点和直线关系
//1在左侧，-1在右侧，0在直线 
int relation(Point A,Point B,Point C)
{
	int c=sgn(Cross((B-A),(C-A)));
	if(c<0) return 1;
	else if(c>0) return -1;
	return 0;
} 

//计算两直线交点
//调用前要确保两直线p+tv和q+tw之间有唯一交点 ，当且仅当Cross(v,w) ！=0 
Point Get_line_intersection(Point P,Vector v,Point Q,Vector w)
{
	Vector u=P-Q;
	double t=Cross(w,u)/Cross(v,w);
	return P+v*t;
} 
Point cross_LL(Point P,Vector v,Point Q,Vector w)
{
	Vector u=P-Q;
	double t=Cross(w,u)/Cross(v,w);
	return P+v*t;
} 


//计算点到直线的距离 
double Distance_point_to_line(Point P,Point A,Point B)
{
	Vector v1=B-A,v2=P-A;
	return fabs(Cross(v1,v2)/Length(v1));
} 

//计算点到线段的距离
//垂线距离或PA或PB
double Distance_point_to_segment(Point P,Point A,Point B)
{
	if(A==B) return Length(P-A);
	Vector v1=B-A,v2=P-A,v3=P-B;
	if(sgn(Dot(v1,v2))<0) return Length(v2);
	if(sgn(Dot(v1,v3))>0) return Length(v3);
	return fabs(Cross(v1,v2)/Length(v1));
} 

//求点在直线上的投影点
Point Get_line_projection(Point P,Point A,Point B)
{
	Vector v=B-A;	
	return A+v*(Dot(v,P-A)/Dot(v,v)); 
} 

//计算点p到直线AB的垂足
Point FootPoint(Point p,Point a,Point b)
{
	Vector x=p-a,y=p-b,z=b-a;
	double len1=Dot(x,z)/Length(z),
		   len2=-1.0*Dot(y,z)/Length(z);
	return a+z*(len1/(len1+len2));
} 



//计算点到直线的对称点
Point symmetry_PL(Point p,Point a,Point b)
{
	return p+(FootPoint(p,a,b)-p)*2;
} 

//判断点是否在线段上
bool OnSegment(Point p,Point a1,Point a2)
{
	return sgn(Cross(a1-p,a2-p))==0&&sgn(Dot(a1-p,a2-p))<0;
}


//判断两线段是否相交

//不算端点相交
bool segment_proper_intersection(Point a1,Point a2,Point b1,Point b2) 
{
	double c1=Cross(a2-a1,b1-a1),
		   c2=Cross(a2-a1,b2-a1);
	double c3=Cross(b2-b1,a1-b1),
		   c4=Cross(b2-b1,a2-b1);
	return sgn(c1)*sgn(c2)<0&&sgn(c3)*sgn(c4)<0;
}
//包含端点处相交
bool Segment_proper_intersection(Point a1,Point a2,Point b1,Point b2)
{
	double c1=Cross(a2-a1,b1-a1),
		   c2=Cross(a2-a1,b2-a1);
	double c3=Cross(b2-b1,a1-b1),
		   c4=Cross(b2-b1,a2-b1);
	if(!sgn(c1)||!sgn(c2)||!sgn(c3)||!sgn(c4))
	{
		bool f1=OnSegment(b1,a1,a2);
		bool f2=OnSegment(b2,a1,a2);
		bool f3=OnSegment(a1,b1,b2);
		bool f4=OnSegment(a2,b1,b2);
		bool f=(f1|f2|f3|f4);
		return f;
	}
	return (sgn(c1)*sgn(c2)<0&&sgn(c3)*sgn(c4)<0);
} 




struct Circle
{
	Point c;
	double r;
	Circle(Point c,double r):c(c),r(r){};
	inline Point point(double a)
	{
		return Point(c.x+cos(a)*r,c.y+sin(a)*r);
	}
};

//求三角形外心
Circle getcircle(Point A,Point B,Point C)
{//三点确定一圆 
	Point P1=(A+B*0.5),P2=(A+C)*0.5;
	Point O=cross_LL(P1,P1+Normal(B-A),P2,P2+Normal(C-A));
	return Circle(O,Length(A-O));
}

//求多边形面积
double convex_polygon_area (Point *p,int n)
{
	double area=0;
	for(int i=1;i<=n-2;i++)
	{
		area+=Cross(p[i]-p[0],p[i+1]-p[0]);
	}
	return fabs(area/2);
}

//判断点在多边形内 
//点在多边形内返回1，在多边形外返回0，在多边形上返回-1
int is_point_in_polygon(Point p,vector<Point> poly)
{//vector<Point> poly ——待判断的点和多边形所有点的集合 
	int wn=0;
	int n=poly.size();
	for(int i=0;i<n;++i)
	{
		if(OnSegment(p,poly[i],poly[(i+1)%n])) return -1;
		int k=sgn(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));
		int d1=sgn(poly[i].y-p.y);
		int d2=sgn(poly[(i+1)%n].y-p.y);
		if(k>0&&d1<=0&&d2>0) wn++;
		if(k<0&&d2<=0&&d1>0) wn--;
	 } 
	if(wn!=0)
		return 1;
	return 0;
} 



#define zero(x) (((x)>0?(x):-(x))<eps)
#define _sign(x) ((x)>eps?1:((x)<eps?2:0))


double xmult(Point p1,Point p2,Point p0)
{
	return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}

double Distance(Point p1,Point p2)
{
	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

double disptoline(Point p,Point l1,Point l2)
{//点到直线距离 
	return fabs(xmult(p,l1,l2)/Distance(l1,l2));
}

Point intersection(Point u1,Point u2,Point v1,Point v2)
{//求两直线交点 
	Point ret=u1;
	double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))/((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));
	ret.x+=(u2.x-u1.x)*t;
	ret.y+=(u2.y-u1.y)*t;
	return ret;
}

//求三角形重心
Point barycenter(Point a1,Point a2,Point a3)
{
	return Point((a1.x+a2.x+a3.x)/3,(a1.y+a2.y+a3.y)/3);
 } 
//求多边形重心
Point barycenter(int n,Point *p)
{
	Point ret,t;
	double t1=0,t2;
	int i;
	ret.x=ret.y=0;
	for(i=1;i<n-1;i++)
	{
		if(fabs(t2=xmult(p[0],p[i],p[i+1]))>eps)
		{
			t=barycenter(p[0],p[i],p[i+1]);
			ret.x+=t.x*t2;
			ret.y+=t.y*t2;
			t1+=t2;
		}
		
	}
	if(fabs(t1)>eps)
		ret.x/=t1,ret.y/=t1;
	return ret;
} 


//判定凸多边形
bool is_convex(int n,Point *p)
{
	int i,s[3]={1,1,1};
	for(i=0;i<n&&s[i]|s[2];i++)
	{
		s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0;
	}
	return s[1]|s[2];
} //允许相邻边共线
 
bool is_convex_v2(int n,Point *p)
{
	int i,s[3]={1,1,1};
	for(i=0;i<n&&s[0]&&s[1]|s[2];i++)
	{
		s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0;
	}
	return s[0]&&s[1]|s[2];
}//不允许相邻边共线 

//判点在凸多边形内或凸多边形上
bool inside_convex(Point q,int n,Point *p)
{
	int i,s[3]={1,1,1};
	for(i=0;i<n&&s[1]|s[2];i++)
	{
		s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0;
	}
	return s[1]|s[2];
} 

//判线段在任意多边形内
int opposite_side(Point p1,Point p2,Point l1,Point l2)
{
	return xmult(l1,p1,l2)*xmult(l1,p2,l2)<-eps;
} 



//两圆相交面积
double AreaOfOverlap(Point c1,double r1,Point c2,double r2)
{
	double d=Length(c1-c2);
	if(r1+r2<d+eps)
		return 0.0;
	if(d<fabs(r1-r2)+eps)
	{
		double r=min(r1,r2);
		return pi*r*r;
	}
	double x=(d*d+r1*r1-r2*r2)/(2.0*d);
	double p=(r1+r2+d)/2.0;
	double t1=acos(x/r1);
	double t2=acos((d-x)/r2);
	double s1=r1*r1*t1;
	double s2=r2*r2*t2;
	double s3=2*sqrt(p*(p-r1)*(p-r2)*(p-d));
	return s1+s2-s3;
} 

//判断直线和圆相交
bool intersect_line(Point c,double r,Point l1,Point l2)
{
	return disptoline(c,l1,l2)<r+eps;
 } 

//判线段与圆相交
bool intersect_seg_circle(Point c,double r,Point l1,Point l2)
{
	double t1=Distance(c,l1)-r,
		   t2=Distance(c,l2)-r;
	Point t=c;
	if(t1<eps||t2<eps)
		return t1>-eps||t2>-eps;
	t.x+=l1.y-l2.y;
	t.y+=l2.x-l1.x;
	return xmult(l1,c,t)*xmult(l2,c,t)<eps&&disptoline(c,l1,l2)-r<eps;
 } 

//判断圆和圆相交
int intersect_circle_circle(Point c1,double r1,Point c2,double r2)
{
	return Distance(c1,c2)<r1+r2+eps&&Distance(c1,c2)>fabs(r1-r2)-eps; 
} 

//圆上到点p最近点 
Point dot_to_circle(Point c,double r,Point p)
{
	Point u,v;
	if(Distance(p,c)<eps)
		return p;
	u.x=c.x+r*fabs(c.x-p.x)/Distance(c,p);
	u.y=c.y+r*fabs(c.y-p.y)/Distance(c,p)*((c.x-p.x)*(c.y-p.y)<0?-1:1);
	v.x=c.x-r*fabs(c.y-p.y)/Distance(c,p);
	v.y=c.y-r*fabs(c.y-p.y)/Distance(c,p)*((c.x-p.x)*(c.y-p.y)<0?-1:1);
	return Distance(u,p)<Distance(v,p)?u:v;
}

//计算直线线段与圆的交点
//线段可以用这个函数求得交点之后再判断点是否在线段上
void intersrction_line_circle(Point c,double r,Point l1,Point l2,Point &p1,Point &p2)
{
	Point p=c;
	double t;
	p.x+=l1.y-l2.y;
	p.y+=l2.x-l1.x;
	p=intersection(p,c,l1,l2);
	t=sqrt(r*r-Distance(p,c)*Distance(p,c))/Distance(l1,l2);
	p1.x=p.x+(l2.x-l1.x)*t;
	p1.y=p.y+(l2.y-l1.y)*t;
	p2.x=p.x-(l2.x-l1.x)*t;
	p2.y=p.y-(l2.y-l1.y)*t;
 } 
 
//求圆外一点poi对圆(o,r)的两个切点 
void TangentPoint_PC(Point poi,Point o,double r,Point &result1,Point &result2)
{
	double line=sqrt((poi.x-o.x)*(poi.x-o.x)+(poi.y-o.y)*(poi.y-o.y));
	double angle=acos(r/line);
	Point unitvector,lin;
	lin.x=poi.x-o.x;
	lin.y=poi.y-o.y;
	unitvector.x=lin.x/sqrt(lin.x*lin.x+lin.y*lin.y)*r;
	unitvector.y=lin.y/sqrt(lin.x*lin.x+lin.y+lin.y)*r;
	result1=Rotate(unitvector,-angle);
	result2=Rotate(unitvector,angle);
	result1.x+=o.x;
	result2.x+=o.x;
	result1.y+=o.y;
	result2.y+=o.y;
	return;
}

//求三角形外接圆
Circle get_circumcircle(Point p1,Point p2,Point p3)
{
	double Bx=p2.x-p1.x,By=p2.y-p1.y;
	double Cx=p3.x-p1.x,Cy=p3.y-p1.y;
	double D=2*(Bx*Cy-By*Cx);
	double ansx=(Cy*(Bx*Bx+By*By)-By*(Cx*Cx+Cy*Cy))/D+p1.x;
	double ansy=(Bx*(Cx*Cx+Cy*Cy)-Cx*(Bx*Bx+By*By))/D+p1.y;
	Point p(ansx,ansy);
	return Circle(p,Length(p1-p));
 } 

//求三角形的内接圆
Circle get_incircle(Point p1,Point p2,Point p3)
{
	double a=Length(p2-p3);
	double b=Length(p3-p1);
	double c=Length(p1-p2);
	Point p=(p1*a+p2*b+p3*c)/(a+b+c);
	return Circle(p,disptoline(p,p1,p2));
 } 

int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}

//多边形上的网格点个数
int grid_onedge(int n,Point *p)
{
	int i,ret=0;
	for(i=0;i<n;i++)
		ret+=gcd(abs(p[i].x-p[(i+1)%n].x),abs(p[i].y-p[(i+1)%n].y));
	return ret;
}

//多边形内的网格点个数
int grid_inside(int n,Point *p)
{
	int i,ret=0;
	for(i=0;i<n;i++)
		ret+=p[(i+1)%n].y*(p[i].x-p[(i+2)%n].x);
	return (abs(ret)-grid_onedge(n,p))/2+1;
 } 

//求凸包
vector<Point> ConvexHull(vector<Point> p)
{
	vector<Point> ch;
	sort(p.begin(),p.end());

	for(int i=0;i<p.size();++i)
	{
		while(ch.size()>1&&Cross(ch[ch.size()-1]-ch[ch.size()-2],p[i]-ch[ch.size()-2])<=0)
			ch.erase(ch.begin()+ch.size()-1);
		ch.push_back(p[i]);
	}
	int k=ch.size();
	for(int i=p.size()-2;i>=0;--i)
	{
		while(ch.size()>k&&Cross(ch[ch.size()-1]-ch[ch.size()-2],p[i]-ch[ch.size()-2])<=0)
			ch.erase(ch.begin()+ch.size()-1);
		ch.push_back(p[i]);
	}

	return ch;
}
```



<div style="page-break-after: always;"></div>

# 附录1 常见算法的复杂度

## 字符串处理

|      算法名称       |           时间复杂度           | 空间复杂度 |
| :-----------------: | :----------------------------: | :--------: |
|      AC自动机       | O(n+关键词长度和+匹配到的次数) |            |
|      KMP/e-KMP      |             O(n+m)             |   O(n+m)   |
|   Boyer-Moore算法   |             O(n+m)             |            |
|     字符串Hash      |             O(n+m)             |            |
|   Rabin-Karp算法    |             O(n+m)             |            |
|    Manacher算法     |              O(n)              |            |
| 最长公共子序列(LCS) |            O(nlogn)            |            |
| 最长递增子序列(LIS) |            O(nlogn)            |            |
|  后缀数组-DC3算法   |              O(n)              |    O(n)    |
|   后缀数组-DA算法   |            O(nlogn)            |            |



## 数学

|             算法名称              |   时间复杂度    | 空间复杂度 |
| :-------------------------------: | :-------------: | :--------: |
|              快速幂               |     O(logn)     |            |
|              埃氏筛               |  O(nlog(logn))  |            |
|              欧拉筛               |      O(n)       |            |
|         Miller-Rabin算法          |    O(Slogn)     |            |
|        Meissel-Lehmer算法         | O(n的(2/3)次方) |            |
|    欧拉函数-求单个数的欧拉函数    |   O(sqrt(x))    |            |
|      欧拉函数-筛法求欧拉函数      |      O(n)       |            |
| 欧拉函数-线性筛求欧拉函数和质数表 |      O(n)       |            |
|          辗转相除法求gcd          |     O(logn)     |            |
|              杜教筛               | O(n的(2/3)次方) |            |
|          FFT-高精度乘法           |    O(nlogn)     |            |



## 数据结构

|      算法名称      |                 时间复杂度                 | 空间复杂度 |
| :----------------: | :----------------------------------------: | :--------: |
|      区间合并      |                  O(nlogn)                  |            |
|  并查集-查询/合并  |              O(logn),接近O(1)              |            |
|      树状数组      |       构造O(nlogn),查询和修改O(logn)       |            |
|       线段树       |                  O(logn)                   |            |
| RMQ问题ST算法-一维 |          预处理O(mlogn),查询O(1)           |            |
| RMQ问题ST算法-二维 |        预处理O(n平方logn),查询O(1)         |            |
|       K-D树        |       插入和查询平均O(logn),最坏O(n)       |            |
|       左偏树       | 求最值O(1),删除最值O(logn),合并两树O(logn) |            |



## 博弈

|    算法名称    | 时间复杂度 | 空间复杂度 |
| :------------: | :--------: | :--------: |
|    巴什博弈    |    O(n)    |            |
| 巴什博弈的组合 |   O(n*m)   |            |
|    尼姆博弈    |    O(n)    |            |



## 图论

|         算法名称          |  时间复杂度   | 空间复杂度 |
| :-----------------------: | :-----------: | :--------: |
|        Kruskal算法        |   O(eloge)    |            |
|         Prim算法          |  O(n的2次方)  |            |
|         拓扑排序          |    O(n+m)     |            |
|     一笔画问题/欧拉路     | 邻接表O(n+m)  |            |
|   强连通分量-Tarjan算法   |    O(n+m)     |            |
| 单源最短路径-Dijkstra算法 |   O(mlogn)    |            |
|   单源最短路径-SPFA算法   |     O(nm)     |            |
|  多源最短路径-Floyd算法   |  O(n的3次方)  |            |
| 二分图最大匹配-匈牙利算法 |     O(nm)     |            |
|       网络流-最大流       |   O(nmlogC)   |            |
|       网络流-关键边       | O(n的2次方*m) |            |



<div style="page-break-after: always;"></div>

# 附录2 输入与输出

## 输入

### 整行含空格输入到string

使用`scanf()`或`cin`输入一行或多行后再使用整行读取前要通过语句`getchar();`舍弃上一行行末换行符。

整行输入到字符串`str`中，使用语句`getline(cin,str);`



### 使用string向stringstream按格式输入

```c++
string data="10 0.5";
int a;
double b;
istringstream iss(data);
iss>>a>>b;
```



## 输出

### 使用stringstream向string按格式输出

```c++
int a=10;
double b=0.5;
ostringstream oss;
oss<a<<" "<<b;
string str=oss.str();
```



## 输入输出速度优化

### 取消cin和cout缓冲区同步

使cin和cout与scanf和printf具有相同的执行速度，防止输入输出在1e5~1e6量级上TLE。

```c++
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
//不可使用endl，否则缓冲区同步会打开
```



<div style="page-break-after: always;"></div>

# 附录3 C++标准库(STL)

## 常见操作时间复杂度

**注意：unordered_map和unordered_set与map和set的操作的时间复杂度不同。**

unordered_map和unordered_set在下表中所列复杂度为平均复杂度，严重哈希冲突情况下退化为O(n)

|               |   访问   | push_back() | push_front() | insert() | pop_back() | pop_front() | erace()  |  find()  |
| :-----------: | :------: | :---------: | :----------: | :------: | :--------: | :---------: | :------: | :------: |
|     list      |   O(n)   |    O(1)     |     O(1)     |   O(1)   |    O(1)    |    O(1)     |   O(1)   |          |
|    vector     |   O(1)   |    O(1)     |      \       |   O(n)   |    O(1)    |      \      |   O(n)   |          |
|     deque     |   O(1)   |    O(1)     |     O(1)     |   O(n)   |    O(1)    |    O(1)     |   O(n)   |          |
|      map      | O(log n) |      \      |      \       | O(log n) |     \      |      \      | O(log n) | O(log n) |
|   multimap    | O(log n) |             |              | O(log n) |            |             | O(log n) | O(log n) |
|      set      | O(log n) |      \      |      \       | O(log n) |     \      |      \      | O(log n) | O(log n) |
| unordered_set |   O(1)   |             |              |   O(1)   |            |             |   O(1)   |   O(1)   |
|   multiset    | O(log n) |             |              | O(log n) |            |             | O(log n) | O(log n) |

`lower_bound()`，`upper_bound()`，`equal_range()`底层为二分查找，时间复杂度O(logn)



## 容器

### 向量 vector

`#include <vector>` 头文件

`vector<int> v(a.begin()+i,a.begin()+j);` 从vector a中截取下标为[i,j)区间的元素构成vector v

`v.push_back(a)` 尾部插入

`v.insert(v.begin()+i,a)` 中间插入

`v.erase(v.begin()+i)` 删除元素

`v.erase(v.begin()+i,v.begin()+j)` 删除区间v[i...(j-1)]

`v.clear()` 清空

`v.size()` 返回vector中元素数量

`v[i]` 访问下标为i的元素



### 队列 queue

`q.push(a)` 尾部插入

`q.pop()` 移除头部元素 **（注意：不要在队列为空时使用）**（注意：不可用a=q.pop()方式取头部元素并移除，必须先a=q.front()再q.pop()）

`q.front()` 返回队头元素，但不移除 **（注意：当队列从有元素到清空时，在队列为空时会一直返回最后一个被弹出的元素）**

`q.back()` 返回队尾元素，但不移除 **（注意：当队列从有元素到清空时，在队列为空时会一直返回最后一个被弹出的元素）**

`q.empty()` 检查队列是否为空，为空则返回`true`，否则返回`false`

`q.size()` 返回queue中元素数量

不可通过下标直接访问



### 优先队列 priority_queue

默认最大堆，需要最小堆的话声明语句为`priority_queue<int,vector<int>,greater<int>> q;`，最大堆也可使用声明语句`priority_queue<int,vector<int>,less<int>> q;` ；使用`greater`和`less`语句时需包含头文件`#include <functional>`

`q.push(a)` 插入新元素，效果与`emplace`相同，但先产生副本再移动到容器中

`q.pop()` 移除优先级最高的元素 **（注意：不要在队列为空时使用）**

`q.top()` 返回最顶层元素，但不移除 **（注意：当队列从有元素到清空时，在队列为空时会一直返回最后一个被弹出的元素）**

`q.empty()` 检查队列是否为空，为空则返回`true`，否则返回`false`

`q.size()` 返回queue中元素数量

`q.emplace(a)` 在顶部插入新元素，效果与`push`相同，但直接在队列头构造，效率略高于`push`

不可通过下标直接访问



### 双端队列 deque

`q.push_back(a)` 在队尾插入新元素

`q.push_front(a)` 在队头插入新元素

`q.pop_back()` 移除队尾元素 **（注意：不要在队列为空时使用）**

`q.pop_front()` 移除队头元素 **（注意：不要在队列为空时使用）**

`q.front()` 返回队头元素，但不移除

`q.back()` 返回队尾元素，但不移除 **（注意：当队列从有元素到清空时，在队列为空时会一直返回最后一个被弹出的元素）**

`q[i]` 访问下标为i的元素



### 栈 stack

`s.push(a)` 插入新元素

`s.pop()` 弹出栈顶元素

`s.top()` 返回栈顶元素，但不移除

不可通过下标直接访问



### 集合 set

> **有序**地存储**互异**元素的容器。由节点组成的红黑树实现。
>
> 默认使用关键字`<`比较进行排序，使用自定义方式排序需使用下列语句：
>
> ```c++
> bool cmp(const int &a,const int &b)
> {
>     return a>b;
> }
> int main()
> {
>     set<int,cmp> st;
> }
> ```

`st.insert(a)` 插入新元素

`st.find(a)` 查找元素a，若找到则返回迭代器，若未找到则返回`st.end()`

`st.count(a)` 统计元素a出现次数（不大于1，因为自动去重）

`st.erase(a)` 删除元素a（可删除不存在的元素）

`st.erase(ite)` 删除迭代器ite指向的元素**（注意：不可删除不存在的元素，最好先find再删除）**

`st.erase(ite1,ite2)` 删除迭代器ite1到ite2之间的元素，区间为`[ite1,ite2)`，**左闭右开**

`st.lower_bound(a)` 查找>=a的第一个元素，返回迭代器

`st.upper_bound(a)` 查找>a的第一个元素，返回迭代器

`st.equal_range(a)` 查找元素a出现的范围，返回一个迭代器pair，其first为`st.lower_bound(a)`，其second为`st.upper_bound(a)`



### 多重集合 multiset

> **有序**地存储**允许重复的**元素的容器。由节点组成的红黑树实现。

`st.insert(a)` 插入新元素

`st.find(a)` 查找元素a，若找到则返回迭代器指向a**第一次**出现的位置，若未找到则返回`st.end()`

`st.count(a)` 统计元素a出现次数

`st.erase(a)` 删除元素a（可删除不存在的元素），**若有多项则一起删除**，若要仅删除一项则可使用st.erase(st.find(a))

`st.erase(ite)` 删除迭代器ite指向的元素**（注意：不可删除不存在的元素，最好先find再删除）**

`st.erase(ite1,ite2)` 删除迭代器ite1到ite2之间的元素，区间为`[ite1,ite2)`，**左闭右开**

`st.lower_bound(a)` 查找>=a的第一个元素，返回迭代器

`st.upper_bound(a)` 查找>a的第一个元素，返回迭代器

`st.equal_range(a)` 查找元素a出现的范围，返回一个迭代器pair，其first为`st.lower_bound(a)`，其second为`st.upper_bound(a)`



### 无序集合 unordered_set

> **无序**地存储**互异**元素的容器。由hash散列表实现。

除了不可使用`st.lower_bound(a)`，`st.equal_range(a)`，`st.equal_range(a)` 等仅适用于有序容器的接口外，其余与set相同。

**迭代器仅可单向迭代，不可反向迭代。**

存在unordered_multiset，即multiset的无序版本。



### 映射 map

> **有序**地存储key和value对应关系的容器，**key值唯一**。由节点组成的红黑树实现。
>
> 默认对key值使用关键字`<`比较进行排序，使用自定义方式排序需使用下列语句：
>
> ```c++
> bool cmp(const pair<int,int> &a,const pair<int,int> &b)
> {
>     return a.second>b.second;
> }
> int main()
> {
>     map<int,int,cmp> mp;
> }
> ```

`mp.insert(make_pair(a,b))` 插入新元素

`mp.find(a)` 查找key值a，若找到则返回迭代器，若未找到则返回`st.end()`

`mp.count(a)` 统计key值中元素a出现次数（不大于1，因为同key值自动去重）

`mp.erase(a)` 删除key值a对应的pair（可删除不存在的元素）

`mp[a]` 访问key值a，返回其对应的value值

只可通过遍历的方式，用value找其对应的key值

`mp.lower_bound(a)` 查找key>=a的第一个元素，返回迭代器

`mp.upper_bound(a)` 查找key>a的第一个元素，返回迭代器



### 多重映射 multimap

> **有序**地存储key和value对应关系的容器，**key值允许重复**。由节点组成的红黑树实现。

`mp.insert(make_pair(a,b))` 插入新元素

`mp.find(a)` 查找key值a，若找到则返回迭代器指向key值a**第一次**出现的位置，若未找到则返回`mp.end()`

`mp.count(a)` 统计key值中元素a出现次数

`mp.erase(a)` 删除key值a对应的pair（可删除不存在的元素），若存在多个则删除其中的一个

`mp.erase(ite)` 删除迭代器ite指向的元素**（注意：不可删除不存在的元素，最好先find再删除）**

`mp.erase(ite1,ite2)` 删除迭代器ite1到ite2之间的元素，区间为`[ite1,ite2)`，**左闭右开**

不可通过key值直接访问value，只能使用find找第一次出现的位置，使用迭代器依次遍历

只可通过遍历的方式，用value找其对应的key值



### 无序映射 unordered_map

> **无序**地存储key和value对应关系的容器。由hash散列表实现。

除了不可使用`mp.lower_bound(a)`，`mp.equal_range(a)`，`mp.equal_range(a)` 等仅适用于有序容器的接口外，其余与map相同。

**迭代器仅可单向迭代，不可反向迭代。**

存在unordered_multimap，即multimap的无序版本。



### 01数组 bitset

`bitset<N> b(x);` 初始化bitset，共N位，N为常数或const int。构造函数参数x指将b初始化为x对应的二进制数，x可为十进制数或字符串，可缺省。字符串高位不足部分用"0"补齐。

`b.set(pos,v)` 设置第pos位为v（bool型，true/false），第二参数缺省则默认为true，两参数都缺省则默认为将所有位置为true

`b.to_ulong()` 将bitset转换成unsigned long，返回值为二进制数b对应的十进制整数

`b.to_ullong()` 将bitset转换成unsigned long long，返回值为二进制数b对应的十进制整数

`b[i]` 访问第i位，从0开始，从低位到高位计数

`cout<<b` 将b从高位到低位顺序输出，输出01串，高位不足部分用"0"补齐



## 函数

### 求两集合差集 set_difference

仅适用于**有序**容器，例如set,map,排序后的vector,排序后的数组等。

需注意参数顺序，本例中顺序为求iarr1-iarr2，即iarr1中有而iarr2中没有的元素，交换参数顺序可求iarr2-iarr1。

```c++
int main(void)
{
    int iarr1[]={1,2,3,3,6,7,4,5};
    int iarr2[]={1,4,3,10,9};
    std::sort(begin(iarr1),end(iarr1));
    std::sort(begin(iarr2),end(iarr2));
    vector<int> ivec(10);  
    auto iter=set_difference(begin(iarr1),end(iarr1),begin(iarr2),end(iarr2),ivec.begin());    //ivec为：2,3,5,6,7
    ivec.resize(iter-ivec.begin());//重新确定ivec大小
    return 0;
}
```



### 求两集合并集 set_union

仅适用于**有序**容器，例如set,map,排序后的vector,排序后的数组等。

参数与set_difference相同。



### 求两集合交集 set_intersection

仅适用于**有序**容器，例如set,map,排序后的vector,排序后的数组等。

参数与set_difference相同。



### 去重 unique

去除**相邻**的重复元素，返回指向去重后容器结尾的迭代器，原容器的大小不变。

通常先sort，后unique，以实现去重。

```c++
vector<int> v;
unique(v.begin(),v.end());
```



### 翻转 reverse

用于翻转数组、字符串。

```c++
vector<int> v;
reverse(v.begin(),v.end());
```



### 排序

#### 自动排序 sort

自动选取合适的排序方式，平均时间复杂度O(nlogn)。

**注意：此排序是不稳定的，即在关键字相同的情况下，不同元素先后顺序可能改变。**

排序语句`sort(v.begin(),v.end(),cmp)`，第三个参数缺省时默认按从小到大排序。



#### 部分排序 partial_sort

仅对前m个元素排序，剩余元素不保证顺序，时间复杂度O(nlogm)。

排序语句`partial_sort(v.begin(),v.begin()+m,v.end(),cmp)`，第四个参数缺省时默认按从小到大排序。



#### 稳定排序 stable_sort

时间复杂度O(nlogn)。

此排序是稳定的，即在关键字相同的情况下，不同元素先后顺序不改变。

排序语句`stable_sort(v.begin(),v.end(),cmp)`，第三个参数缺省时默认按从小到大排序。



#### 合并两个有序容器 merge

合并两个有序容器，时间复杂度O(n+m)。

**注意：存储合并结果的容器需预先分配足够大的空间。**

合并语句`merge(a.begin(),a.end(),b.begin(),b.end(),r.begin())`，将vector a和b合并，存储到vector r中。



### 找最大值——max_element() / 找最小值——min_element()

```c++
#include <algorithm>
#include <iostream>

using namespace std;
struct structs 
{
	bool operator() (int i, int j) 
{
 return i<j; 
}
} structs;
//此处也可以直接用bool bools(int i, int j) { return i<j; }
void main()
{
	int ints[] = { 3,5,7,2,7,6,4 };
//方法一
cout << "方法一最大值地址是" << max_element(ints, ints + 7, structs) << endl;
cout << "方法一最大值的位置是"  << *max_element(ints, ints + 7, structs ) << endl;
//方法二
cout << "方法二最大值地址是" << max_element(ints, ints + 7) << endl;
cout << "方法二最大值的位置是"  << *max_element(ints, ints + 7) << endl;
//如果不加*获取的是他的地址
int pos = *max_element(ints, ints + 7);
	int i;
	for (i = 0; i < 10; i++)
	{
		if (ints[i] == pos)
		{
			break;
		}
	}
	cout << "最大值的位置是" << i + 1 << endl;
}
```



### 生成全排列——next_permutation/prev_permutation

函数原型

```c++
#include <algorithm>
bool next_permutation(iterator start,iterator end)
```

当当前序列不存在下一个排列时，函数返回false，否则返回true

```c++
#include <iostream>  
#include <algorithm>  
using namespace std;  
int main()  
{  
    int num[3]={1,2,3};  //此处必须是有序的，否则会遗漏部分排列
    do  
    {  
        cout<<num[0]<<" "<<num[1]<<" "<<num[2]<<endl;  
    }while(next_permutation(num,num+3));  
    return 0;  
}  
```

### 二进制数中1的个数——__builtin_popcount(int x)

## 字符串string与字符数组char[]

### string转char数组

```c++
string str;
char c[256];
cin>>str;
sprintf_s(c,str.c_str());
```

### char数组转string

```c++
char c[256]="example";
string s;
stringstream ss;
ss<<c;
s=ss.str();
ss.str("");	//用完清空
```



## math库

### 三角函数

参数为弧度制

`sin(x)` `cos(x)` `tan(x)`



### 反三角函数

返回值以弧度制表示，反正弦、反正切返回值范围[-pi/2,pi/2]，反余弦返回值范围[0,pi]，特殊反正切返回值范围[-pi,pi]

`asin(x)` `acos(x)` `atan(x)`

`atan2(x,y)` x和y为横纵坐标，计算y/x的反正切，返回值范围[-pi,pi]



### 双曲函数

参数为弧度制

`sinh(x)` `cosh(x)` `tanh(x)`



### 对数运算与e

详见数学-对数运算与e



## 运算符重载

例如在结构体中重载`<`运算符如下：

```c++
struct St{
    int a;
	bool operator <(const struct St &s) const {
        return a<s.a;
    }
};
```



## 常数

|     常量     |           值           |       描述       |
| :----------: | :--------------------: | :--------------: |
|    `M_PI`    | 3.14159265358979323846 |     圆周率 π     |
|    `M_E`     | 2.71828182845904523536 | 自然对数的底数 e |
|  `M_LOG2E`   | 1.44269504088896340736 |     log2(e)      |
|  `M_LOG10E`  | 0.43429448190325182765 |     log10(e)     |
|   `M_LN2`    | 0.69314718055994530942 |      ln(2)       |
|   `M_LN10`   | 2.30258509299404568402 |      ln(10)      |
|   `M_PI_2`   | 1.57079632679489661923 |       π/2        |
|   `M_PI_4`   | 0.78539816339744830962 |       π/4        |
|   `M_1_PI`   | 0.31830988618379067154 |       1/π        |
|   `M_2_PI`   | 0.63661977236758134308 |       2/π        |
| `M_2_SQRTPI` | 1.12837916709551257390 |       2/√π       |
|  `M_SQRT2`   | 1.41421356237309504880 |        √2        |
| `M_SQRT1_2`  | 0.70710678118654752440 |       1/√2       |



<div style="page-break-after: always;"></div>

# 附录4 优先级与结合性

|        运算符         |        名称或含义         |  结合性  |
| :-------------------: | :-----------------------: | :------: |
|          ::           |         范围解析          |    无    |
|                       |                           |          |
|           .           |      成员选择 (对象)      | 从左到右 |
|          –>           |    成员选择 (属于指针)    | 从左到右 |
|          [ ]          |         数组下标          | 从左到右 |
|          ( )          |    成员函数调用初始化     | 从左到右 |
|          ++           |         后缀递增          | 从左到右 |
|          ––           |         后缀递减          | 从左到右 |
|       typeid( )       |         类型名称          | 从左到右 |
|      const_cast       |         类型转换          | 从左到右 |
|     dynamic_cast      |         类型转换          | 从左到右 |
|   reinterpret_cast    |         类型转换          | 从左到右 |
|      static_cast      |         类型转换          | 从左到右 |
|                       |                           |          |
|        sizeof         |     对象或类型的范围      | 从右到左 |
|          ++           |         前缀递增          | 从右到左 |
|          ––           |         前缀递减          | 从右到左 |
|           ~           |         1 的补码          | 从右到左 |
|           !           |        逻辑 " 非 "        | 从右到左 |
|           –           |          一元负           | 从右到左 |
|           +           |         一元加号          | 从右到左 |
|           &           |           地址            | 从右到左 |
|           *           |         间接寻址          | 从右到左 |
|          new          |         创建对象          | 从右到左 |
|        delete         |         销毁对象          | 从右到左 |
|          ( )          |           Cast            | 从右到左 |
|                       |                           |          |
|          .*           |   指向成员的指针 (对象)   | 从左到右 |
|          –>*          | 指向成员的指针 (属于指针) | 从左到右 |
|                       |                           |          |
|           *           |           乘法            | 从左到右 |
|           /           |           除法            | 从左到右 |
|           %           |           模数            | 从左到右 |
|                       |                           |          |
|           +           |           添加            | 从左到右 |
|           –           |           减法            | 从左到右 |
|                       |                           |          |
|          <<           |           左移            | 从左到右 |
|          >>           |           右移            | 从左到右 |
|                       |                           |          |
|           <           |           小于            | 从左到右 |
|           >           |           大于            | 从左到右 |
|          <=           |        小于或等于         | 从左到右 |
|          >=           |        大于或等于         | 从左到右 |
|                       |                           |          |
|          ==           |           相等            | 从左到右 |
|          !=           |          不相等           | 从左到右 |
|                       |                           |          |
|           &           |         按位“与”          | 从左到右 |
|           ^           |        按位“异或”         | 从左到右 |
|          \|           |        按位“与或”         | 从左到右 |
|          &&           |         逻辑“与”          | 从左到右 |
|         \|\|          |         逻辑“或”          | 从左到右 |
|                       |                           |          |
| expr1 ? expr2 : expr3 |         条件运算          | 从右到左 |
|                       |                           |          |
|           =           |           赋值            | 从右到左 |
|          *=           |         乘法赋值          | 从右到左 |
|          /=           |         除法赋值          | 从右到左 |
|          %=           |         取模赋值          | 从右到左 |
|          +=           |         加法赋值          | 从右到左 |
|          –=           |         减法赋值          | 从右到左 |
|          <<=          |         左移赋值          | 从右到左 |
|          >>=          |         右移赋值          | 从右到左 |
|          &=           |        按位、赋值         | 从右到左 |
|          \|=          |      包含按位或分配       | 从右到左 |
|          ^=           |    按位 " 异或 " 赋值     | 从右到左 |
|                       |                           |          |
|       throwexpr       |        引发表达式         | 从右到左 |
|                       |                           |          |
|           ,           |           逗号            | 从左到右 |
